<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type="application/javascript" src='https://y-m-m.github.io/js/theme-mode.js'></script>
    <link rel="stylesheet" href='https://y-m-m.github.io/css/frameworks.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github.min.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/github-style.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/light.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/dark.css' />
    <link rel="stylesheet" href='https://y-m-m.github.io/css/syntax.css' />
    <title>操作系统bilibili版 - 陈皮的博客</title>
    
    <link rel="icon" type="image/x-icon" href='/images/github-mark.png'>
    
    <meta name="theme-color" content="#1e2327">

    
    <meta name="description"
  content="第一章 操作系统的介绍 1.1_1 操作系统的概念、功能 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统是系统资源的管理者 补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理 向上提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可 GUI 图形化用户接口 联机命令接口=交互式命令接口 用户说一句，系统跟着做一句 脱机命令接口(批处理命令接口) 程序接口 可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用 例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用” 系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式 在有的教材中，系统调用=广义指令 是最接近硬件的一层软件 需要实现对硬件机器的扩展 裸机：没有任何软件支持的计算机称为裸机 虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机 操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能 总结 1.1_2 操作系统的特征 并发 并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生 操作系统的并发性 计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 注意 单核CPU同一时刻只能执行一个程序，多个程序只能并发执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 是操作系统一个重要的基础特性 共享 资源共享，系统中的资源可供内存中多个并发执行的进程共同使用 两种共享方式 互斥共享方式 一个时间段内只允许一个进程访问该资源 同时共享方式 允许一个时间段内多个进程“同时”对它们进行访问 同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享) 并发和共享的关系 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发 虚拟 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的 虚拟技术 空分复用技术(如虚拟存储技术) 时分复用技术(如虚拟处理器) 并发性与虚拟性的关系 如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了 没有并发性，就谈不上虚拟性 异步 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进 并发性与异步性的关系 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性 总结 1.2 操作系统的发展和分类 手工操作阶段 主要缺点：用户独占全机、人际速度矛盾导致资源利用率低 批处理阶段——单道批处理系统 引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出 监督程序是操作系统的雏形 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 批处理阶段——多道批处理系统 每次往内存中读入多道程序 操作系统正式诞生，用于支持多道程序并发运行 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大 主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数) 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 分类 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统 网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信 分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 总结 " />
<meta name="keywords"
  content='blog, google analytics' />
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />


<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="操作系统bilibili版 - 陈皮的博客" />
<meta name="twitter:description"
  content="第一章 操作系统的介绍 1.1_1 操作系统的概念、功能 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统是系统资源的管理者 补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理 向上提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可 GUI 图形化用户接口 联机命令接口=交互式命令接口 用户说一句，系统跟着做一句 脱机命令接口(批处理命令接口) 程序接口 可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用 例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用” 系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式 在有的教材中，系统调用=广义指令 是最接近硬件的一层软件 需要实现对硬件机器的扩展 裸机：没有任何软件支持的计算机称为裸机 虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机 操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能 总结 1.1_2 操作系统的特征 并发 并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生 操作系统的并发性 计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 注意 单核CPU同一时刻只能执行一个程序，多个程序只能并发执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 是操作系统一个重要的基础特性 共享 资源共享，系统中的资源可供内存中多个并发执行的进程共同使用 两种共享方式 互斥共享方式 一个时间段内只允许一个进程访问该资源 同时共享方式 允许一个时间段内多个进程“同时”对它们进行访问 同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享) 并发和共享的关系 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发 虚拟 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的 虚拟技术 空分复用技术(如虚拟存储技术) 时分复用技术(如虚拟处理器) 并发性与虚拟性的关系 如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了 没有并发性，就谈不上虚拟性 异步 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进 并发性与异步性的关系 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性 总结 1.2 操作系统的发展和分类 手工操作阶段 主要缺点：用户独占全机、人际速度矛盾导致资源利用率低 批处理阶段——单道批处理系统 引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出 监督程序是操作系统的雏形 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 批处理阶段——多道批处理系统 每次往内存中读入多道程序 操作系统正式诞生，用于支持多道程序并发运行 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大 主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数) 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 分类 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统 网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信 分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 总结 " />
<meta name="twitter:site" content="https://y-m-m.github.io/" />
<meta name="twitter:creator" content="陈皮" />
<meta name="twitter:image"
  content="https://y-m-m.github.io/">


<meta property="og:type" content="article" />
<meta property="og:title" content="操作系统bilibili版 - 陈皮的博客">
<meta property="og:description"
  content="第一章 操作系统的介绍 1.1_1 操作系统的概念、功能 操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 操作系统是系统资源的管理者 补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理 向上提供方便易用的服务 封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可 GUI 图形化用户接口 联机命令接口=交互式命令接口 用户说一句，系统跟着做一句 脱机命令接口(批处理命令接口) 程序接口 可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用 例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用” 系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式 在有的教材中，系统调用=广义指令 是最接近硬件的一层软件 需要实现对硬件机器的扩展 裸机：没有任何软件支持的计算机称为裸机 虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机 操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能 总结 1.1_2 操作系统的特征 并发 并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生 操作系统的并发性 计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的 注意 单核CPU同一时刻只能执行一个程序，多个程序只能并发执行 多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行 是操作系统一个重要的基础特性 共享 资源共享，系统中的资源可供内存中多个并发执行的进程共同使用 两种共享方式 互斥共享方式 一个时间段内只允许一个进程访问该资源 同时共享方式 允许一个时间段内多个进程“同时”对它们进行访问 同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享) 并发和共享的关系 如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义 如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发 虚拟 虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的 虚拟技术 空分复用技术(如虚拟存储技术) 时分复用技术(如虚拟处理器) 并发性与虚拟性的关系 如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了 没有并发性，就谈不上虚拟性 异步 异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性 由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进 并发性与异步性的关系 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性 总结 1.2 操作系统的发展和分类 手工操作阶段 主要缺点：用户独占全机、人际速度矛盾导致资源利用率低 批处理阶段——单道批处理系统 引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出 监督程序是操作系统的雏形 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升 批处理阶段——多道批处理系统 每次往内存中读入多道程序 操作系统正式诞生，用于支持多道程序并发运行 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大 主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数) 分时操作系统 计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互 主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在 主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性 实时操作系统 主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队 在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性 分类 硬实时系统：必须在绝对严格的规定时间内完成处理 软实时系统：能接受偶尔违反时间规定 其他几种操作系统 网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信 分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务 个人计算机操作系统 总结 " />
<meta property="og:url" content="https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" />
<meta property="og:site_name" content="操作系统bilibili版" />
<meta property="og:image"
  content="https://y-m-m.github.io/">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">

<meta property="article:published_time" content="2024-09-11 00:00:00 &#43;0000 UTC" />











</head>

<body>
  <div style="position: relative">
  <header class="Header js-details-container Details px-3 px-md-4 px-lg-5 flex-wrap flex-md-nowrap open Details--on">
    <div class="Header-item mobile-none" style="margin-top: -4px; margin-bottom: -4px;">
      <a class="Header-link" href="https://y-m-m.github.io/">
        <img class="octicon" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item d-md-none">
      <button class="Header-link btn-link js-details-target" type="button"
        onclick="document.querySelector('#header-search').style.display = document.querySelector('#header-search').style.display == 'none'? 'block': 'none'">
        <svg height="24" class="octicon octicon-three-bars" viewBox="0 0 16 16" version="1.1" width="24">
          <path fill-rule="evenodd" d="M1 2.75A.75.75 0 011.75 2h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 2.75zm0 5A.75.75 0 011.75 7h12.5a.75.75 0 110 1.5H1.75A.75.75 0 011 7.75zM1.75 12a.75.75 0 100 1.5h12.5a.75.75 0 100-1.5H1.75z">
          </path>
        </svg>
      </button>
    </div>
    <div style="display: none;" id="header-search"
      class="Header-item Header-item--full flex-column flex-md-row width-full flex-order-2 flex-md-order-none mr-0 mr-md-3 mt-3 mt-md-0 Details-content--hidden-not-important d-md-flex">
      <div
        class="Header-search header-search flex-auto js-site-search position-relative flex-self-stretch flex-md-self-auto mb-3 mb-md-0 mr-0 mr-md-3 scoped-search site-scoped-search js-jump-to">
        <div class="position-relative">
          
          <form target="_blank" id="search-form" action="" accept-charset="UTF-8" method="get"
            autocomplete="off">
            <label
              class="Header-search-label form-control input-sm header-search-wrapper p-0 js-chromeless-input-container header-search-wrapper-jump-to position-relative d-flex flex-justify-between flex-items-center">
              <input type="text"
                class="Header-search-input form-control input-sm header-search-input jump-to-field js-jump-to-field js-site-search-focus js-site-search-field is-clearable"
                name="q" value="" placeholder="Search" autocomplete="off">
            </label>
          </form>
          
        </div>
      </div>
    </div>

    <div class="Header-item Header-item--full flex-justify-center d-md-none position-relative">
      <a class="Header-link " href="https://y-m-m.github.io/">
        <img class="octicon octicon-mark-github v-align-middle" height="32" width="32" src="/images/github-mark-white.png">
      </a>
    </div>
    <div class="Header-item" style="margin-right: 0;">
      <a href="javascript:void(0)" class="Header-link no-select" onclick="switchTheme()">
        <svg style="fill: var(--color-profile-color-modes-toggle-moon);" class="no-select" viewBox="0 0 16 16"
          version="1.1" width="16" height="16">
          <path fill-rule="evenodd" clip-rule="evenodd"
            d="M4.52208 7.71754C7.5782 7.71754 10.0557 5.24006 10.0557 2.18394C10.0557 1.93498 10.0392 1.68986 10.0074 1.44961C9.95801 1.07727 10.3495 0.771159 10.6474 0.99992C12.1153 2.12716 13.0615 3.89999 13.0615 5.89383C13.0615 9.29958 10.3006 12.0605 6.89485 12.0605C3.95334 12.0605 1.49286 10.001 0.876728 7.24527C0.794841 6.87902 1.23668 6.65289 1.55321 6.85451C2.41106 7.40095 3.4296 7.71754 4.52208 7.71754Z">
          </path>
        </svg>
      </a>
    </div>
  </header>
</div>

  <div id="search-result" class="container-lg px-3 new-discussion-timeline" style="display: none;">
</div>

  
<div class="application-main">
  <div>
  <main>
    <div class="gisthead pagehead bg-gray-light pb-0 pt-3 mb-4">
      <div class="px-0">
        <div class="mb-3 d-flex px-3 px-md-3 px-lg-5">
          <div class="flex-auto min-width-0 width-fit mr-3">
            <div class="d-flex">
              <div class="d-none d-md-block">
                <a class="avatar mr-2 flex-shrink-0" href="https://y-m-m.github.io/">
                  <img class=" avatar-user"
                    src="/images/me.png"
                    width="32" height="32"></a>
              </div>
              <div class="d-flex flex-column">
                <h1 class="break-word f3 text-normal mb-md-0 mb-1">
                  <span class="author">
                    <a href="https://y-m-m.github.io/">陈皮</a>
                  </span>
                  <span class="path-divider">/</span>
                  <strong class="css-truncate css-truncate-target mr-1" style="max-width: 410px">
                    <a href="https://y-m-m.github.io/post/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统bilibili版</a>
                  </strong>
                </h1>
                <div class="note m-0">
                  Created <relative-time datetime="Wed, 11 Sep 2024 00:00:00 &#43;0000"
                    class="no-wrap">
                    Wed, 11 Sep 2024 00:00:00 &#43;0000</relative-time>

                  
                  <span class="file-info-divider"></span>
                  Modified <relative-time datetime="Tue, 26 Nov 2024 11:21:13 &#43;0800"
                    class="no-wrap">
                    Tue, 26 Nov 2024 11:21:13 &#43;0800</relative-time>
                  
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="container-lg px-3 new-discussion-timeline">
      <div class="repository-content gist-content">
        <div>
          <div class="js-gist-file-update-container js-task-list-container file-box">
            <div id="file-pytest" class="file my-2">
              <div id="post-header" class="file-header d-flex flex-md-items-center flex-items-start sticky-header" style="z-index: 2">
                <div class="file-info d-flex flex-md-items-center flex-items-start flex-order-1 flex-auto">
                  <div class="text-mono f6 flex-auto pr-3 flex-order-2 flex-md-order-1 mt-2 mt-md-0">
                    
                    <summary id="toc-toggle" onclick="clickToc()" class="btn btn-octicon m-0 mr-2 p-2">
                      <svg aria-hidden="true" viewBox="0 0 16 16" height="16" width="16" class="octicon octicon-list-unordered">
                        <path fill-rule="evenodd" d="M2 4a1 1 0 100-2 1 1 0 000 2zm3.75-1.5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zm0 5a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5zM3 8a1 1 0 11-2 0 1 1 0 012 0zm-1 6a1 1 0 100-2 1 1 0 000 2z"></path>
                      </svg>
                    </summary>
                    <details-menu class="SelectMenu" id="toc-details" style="display: none;">
                      <div class="SelectMenu-modal rounded-3 mt-1" style="max-height: 340px;">
                        <div class="SelectMenu-list SelectMenu-list--borderless p-2" style="overscroll-behavior: contain;" id="toc-list">
                        </div>
                      </div>
                    </details-menu>
                      54037 Words
                    

                  </div>
                  <div class="file-actions flex-order-2 pt-0">
                    
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      计算机科学
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      操作系统
                    </a>
                    
                    <a class="muted-link mr-3" href="https://y-m-m.github.io/tags/%E7%AC%94%E8%AE%B0">
                      <svg class="octicon octicon-tag" viewBox="0 0 16 16" version="1.1" width="16" height="16">
                        <path fill-rule="evenodd"
                          d="M2.5 7.775V2.75a.25.25 0 01.25-.25h5.025a.25.25 0 01.177.073l6.25 6.25a.25.25 0 010 .354l-5.025 5.025a.25.25 0 01-.354 0l-6.25-6.25a.25.25 0 01-.073-.177zm-1.5 0V2.75C1 1.784 1.784 1 2.75 1h5.025c.464 0 .91.184 1.238.513l6.25 6.25a1.75 1.75 0 010 2.474l-5.026 5.026a1.75 1.75 0 01-2.474 0l-6.25-6.25A1.75 1.75 0 011 7.775zM6 5a1 1 0 100 2 1 1 0 000-2z">
                        </path>
                      </svg>
                      笔记
                    </a>
                    
                    
                  </div>
                </div>
              </div>


              <div class="Box-body px-5 pb-5" style="z-index: 1">
                <article class="markdown-body entry-content container-lg"><h1 id="第一章-操作系统的介绍">第一章 操作系统的介绍</h1>
<h2 id="11_1-操作系统的概念功能">1.1_1 操作系统的概念、功能</h2>
<ul>
<li>操作系统控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件
<ul>
<li>操作系统是系统资源的管理者
<ul>
<li>补充：执行一个程序前需要将该程序放到内存中，才能被CPU处理</li>
</ul>
</li>
<li>向上提供方便易用的服务
<ul>
<li>封装思想：操作系统把一些丑陋的硬件共嗯那个封装成简单易用的服务，使用户能更方便的使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出指令即可</li>
<li>GUI 图形化用户接口</li>
<li>联机命令接口=交互式命令接口
<ul>
<li>用户说一句，系统跟着做一句</li>
</ul>
</li>
<li>脱机命令接口(批处理命令接口)</li>
<li>程序接口
<ul>
<li>可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用</li>
<li>例如，在写C语言&quot;Hello World&quot;程序时，在printf函数的底层就使用到了操作系统提供的显式相关的“系统调用”</li>
<li>系统调用类似于函数调用，是应用程序请求系统操作服务的唯一方式</li>
<li>在有的教材中，系统调用=广义指令</li>
</ul>
</li>
</ul>
</li>
<li>是最接近硬件的一层软件
<ul>
<li>需要实现对硬件机器的扩展</li>
<li>裸机：没有任何软件支持的计算机称为裸机</li>
<li>虚拟机：覆盖了软件的机器称为扩充机器，又称之为虚拟机</li>
<li>操作系统将CPU, 内存，磁盘，显示器，键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2019.53.51.png" alt=""></p>
<h2 id="11_2-操作系统的特征">1.1_2 操作系统的特征</h2>
<h3 id="并发">并发</h3>
<ul>
<li>并发：两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。/并行：两个或多个事件在同一时刻同时发生</li>
<li>操作系统的并发性
<ul>
<li>计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的</li>
</ul>
</li>
<li>注意
<ul>
<li>单核CPU同一时刻只能执行一个程序，多个程序只能并发执行</li>
<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</li>
</ul>
</li>
<li>是操作系统一个重要的基础特性</li>
</ul>
<h3 id="共享">共享</h3>
<ul>
<li>资源共享，系统中的资源可供内存中多个并发执行的进程共同使用</li>
<li>两种共享方式
<ul>
<li>互斥共享方式
<ul>
<li>一个时间段内只允许一个进程访问该资源</li>
</ul>
</li>
<li>同时共享方式
<ul>
<li>允许一个时间段内多个进程“同时”对它们进行访问</li>
<li>同时往往是宏观上的，微观上，这些进程可能是交替地对该资源进行访问的(分时共享)</li>
</ul>
</li>
</ul>
</li>
<li>并发和共享的关系
<ul>
<li>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</li>
<li>如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li>
</ul>
</li>
</ul>
<h3 id="虚拟">虚拟</h3>
<ul>
<li>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体(前者)是实际存在的，而逻辑上的对应物(后者)是用户感应到的</li>
<li>虚拟技术
<ul>
<li>空分复用技术(如虚拟存储技术)</li>
<li>时分复用技术(如虚拟处理器)</li>
</ul>
</li>
<li>并发性与虚拟性的关系
<ul>
<li>如果失去了并发性，则一个时间段内系统中之运行一道程序，那么就失去了实现虚拟性的意义了</li>
<li>没有并发性，就谈不上虚拟性</li>
</ul>
</li>
</ul>
<h3 id="异步">异步</h3>
<ul>
<li>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性</li>
<li>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进</li>
<li>并发性与异步性的关系
<ul>
<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底，只有程序拥有并发性，才有可能导致异步性</li>
</ul>
</li>
</ul>
<h3 id="总结-1">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.16.20.png" alt=""></p>
<h2 id="12-操作系统的发展和分类">1.2 操作系统的发展和分类</h2>
<ul>
<li>手工操作阶段
<ul>
<li>主要缺点：用户独占全机、人际速度矛盾导致资源利用率低</li>
</ul>
</li>
<li>批处理阶段——单道批处理系统
<ul>
<li>引入脱机输入/输出技术，并由监督程序负责控制作业的输入、输出</li>
<li>监督程序是操作系统的雏形</li>
<li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</li>
</ul>
</li>
<li>批处理阶段——多道批处理系统
<ul>
<li>每次往内存中读入多道程序</li>
<li>操作系统正式诞生，用于支持多道程序并发运行</li>
<li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌“状态，系统吞吐量大</li>
<li>主要缺点：用户响应时间长，没有人机交互功能(用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。无法调试程序/无法在程序运行过程中输入一些参数)</li>
</ul>
</li>
<li>分时操作系统
<ul>
<li>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互</li>
<li>主要优点：用户请求可以被即时相应，解决了人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</li>
<li>主要缺点：不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</li>
</ul>
</li>
<li>实时操作系统
<ul>
<li>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队</li>
<li>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。实时操作系统的主要特点是及时性和可靠性</li>
<li>分类
<ul>
<li>硬实时系统：必须在绝对严格的规定时间内完成处理</li>
<li>软实时系统：能接受偶尔违反时间规定</li>
</ul>
</li>
</ul>
</li>
<li>其他几种操作系统
<ul>
<li>网络操作系统 实现数据传送等功能，实现网络中各种资源的共(如文件共享)和各台计算机之间的通信</li>
<li>分布式操作系统：分布性和并行性。系统中各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</li>
<li>个人计算机操作系统</li>
</ul>
</li>
</ul>
<h3 id="总结-2">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.29.42.png" alt=""></p>
<h2 id="13_1-操作系统的运行机制">1.3_1 操作系统的运行机制</h2>
<ul>
<li>预备知识：程序是如何运行的？
<ul>
<li>C语言代码-(编译器)-&gt;机器指令</li>
<li>指令：处理器能识别、执行的最基本命令</li>
</ul>
</li>
<li>内核程序vs.应用程序
<ul>
<li>内核程序：实现操作系统的程序，很多内核程序组成了“操作系统内核”，或简称“内核”，内核是操作系统最重要最核心的部分，也是最接近硬件的部分，内核实现管理功能
<ul>
<li>甚至可以说，一个操作系统只要有内核就够了(Docker-&gt;仅需Linux内核)</li>
<li>操作系统的功能未必都在内核中，如图形化用户界面GUI</li>
</ul>
</li>
<li>应用程序：运行在操作系统之上，只能使用非特权指令</li>
</ul>
</li>
<li>特权指令vs.非特权指令
<ul>
<li>特权指令：只允许“管理者”——即操作系统内核来使用</li>
<li>非特权指令</li>
<li>CPU设计和生产的时候就划分了特权指令和非特权指令</li>
</ul>
</li>
<li>内核态vs.用户态(CPU的状态)
<ul>
<li>内核态，正在运行内核程序，此时可以执行特权指令</li>
<li>用户态，正在运行应用程序，只能执行非特权指令</li>
<li>CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，1表示“内核态”，0表示“用户态”</li>
<li>别名：内核态=核心态=管态，用户态=目态</li>
</ul>
</li>
<li>内核态、用户态的切换
<ul>
<li>开机时，CPU为内核态，操作系统内核程序先上CPU运行</li>
<li>开机完成后，用户可以启动某个应用程序</li>
<li>操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行(操作系统内核在让出CPU之前，会用一条特权指令把PSW的标志位设置为“用户态”)</li>
<li>应用程序运行在“用户态”</li>
<li>黑客在应用程序中植入一条特权指令，但是自己又处于“用户态”</li>
<li>这个非法时间会引发一个中断信号(CPU检测到<strong>中断</strong>信号后，会立即变为“核心态”，并停止运行当前的应用程序，转而运行处理中断信号的内核程序)</li>
<li>“中断”使操作系统再次夺回CPU的控制权</li>
<li>操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序</li>
<li>总结
<ul>
<li>内核态-&gt;用户态：执行一条<strong>特权指令</strong>——修改PSW的标志位为用户态，这个动作意味着操作系统将主动让出CPU使用权</li>
<li>用户态-&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。
<ul>
<li>但凡需要操作系统介入的地方，都会触发中断信号
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-11%2022.47.16.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="13_2-中断和异常">1.3_2 中断和异常</h2>
<ul>
<li>中断的作用
<ul>
<li>“中断”是让操作系统内核夺回CPU使用权的唯一途径</li>
<li>能够使CPU从用户态变为内核态</li>
</ul>
</li>
<li>中断的类型
<ul>
<li>内中断(也称异常、例外)
<ul>
<li>与当前执行的指令有关，中断信号来源于CPU内部</li>
<li>若当前执行的指令是非法的，则会引发一个中断信号</li>
<li>例
<ul>
<li>试图在用户态下执行特权指令</li>
<li>执行除法指令时发现除数为0</li>
<li>有时候应用程序想请求操作系统的服务，此时会执行一条特殊指令——陷入指令，该指令会引发一个内部中断信号
<ul>
<li>系统调用通过陷入指令完成</li>
</ul>
</li>
</ul>
</li>
<li>分类：陷阱、陷入trap，故障(由错误条件引起，可能被内核程序修复)，中止(由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如：整数除0、非法使用特权指令)</li>
</ul>
</li>
<li>外中断(也称中断)
<ul>
<li>与当前执行的指令无关，中断信号来源于CPU外部</li>
<li>例
<ul>
<li>时钟中断——由时钟部件发来的中断信号</li>
<li>I/O中断——由输入/输出设备发来的中断信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中断机制的基本原理
<ul>
<li>不同的中断信号，需要不同的中断处理程序来处理。</li>
<li>当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置</li>
</ul>
</li>
</ul>
<h3 id="总结-3">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.21.55.png" alt=""></p>
<h2 id="133-系统调用">1.3.3 系统调用</h2>
<ul>
<li>系统调用是操作系统提供给应用程序(程序员/编程人员)使用的接口，可以理解为一种可供应用程序调用的特殊函数，应用程序可以通过系统调用来请求获得操作系统内核的服务</li>
<li>系统调用与库函数的区别
<ul>
<li>应用程序通过库函数请求系统调用</li>
</ul>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: center">分类</th>
          <th style="text-align: center">特性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">普通应用程序</td>
          <td style="text-align: center">可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及</td>
      </tr>
      <tr>
          <td style="text-align: center">编程语言</td>
          <td style="text-align: center">向上提供库函数，以隐藏系统调用的一些细节，使程序员编程更加方便</td>
      </tr>
      <tr>
          <td style="text-align: center">操作系统</td>
          <td style="text-align: center">向上提供系统调用，使得上层程序能够请求内核的服务</td>
      </tr>
      <tr>
          <td style="text-align: center">裸机</td>
          <td style="text-align: center"></td>
      </tr>
  </tbody>
</table>
<ul>
<li>系统调用(按功能分类)
<ul>
<li>设备管理</li>
<li>文件管理</li>
<li>进程控制</li>
<li>进程通信</li>
<li>内存管理</li>
</ul>
</li>
<li>凡是与共享资源有关的操作(如存储分配，I/O操作，文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成，这样可以保证系统的稳定性和安全性，防止用户进行非法操作</li>
<li>系统调用的过程
<ul>
<li>传参指令1 系统调用类型</li>
<li>传参指令2 其他参数</li>
<li>陷入指令-&gt;内中断信号，转入相应的中断处理程序(用户态)</li>
<li>系统调用入口程序</li>
<li>系统调用的处理程序(核心态)</li>
<li>返回应用程序</li>
<li>注意
<ul>
<li>陷入指令是在用户态执行的，执行陷入指令之后引发一个内中断，使CPU进入核心态</li>
<li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行</li>
<li>陷入指令=trap指令=访管指令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-4">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.50.57.png" alt=""></p>
<h2 id="14_1-操作系统体系结构上">1.4_1 操作系统体系结构(上)</h2>
<ul>
<li>大内核(宏内核/单内核)
<ul>
<li>内核态进行进程管理、存储管理、设备管理、时钟管理、中断处理、原语</li>
</ul>
</li>
<li>微内核
<ul>
<li>内核态进行时钟管理、中断处理、原语，用户态进行进程管理、存储管理、设备管理
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.54.32.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2008.57.06.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.01.25.png" alt=""></li>
</ul>
</li>
<li>分层结构</li>
<li>模块化</li>
<li>外核</li>
</ul>
<h3 id="总结-5">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.03.08.png" alt=""></p>
<ul>
<li>典型的大内核/宏内核/单内核操作系统：Linux, UNIX</li>
<li>典型的微内核操作系统: Windows NT</li>
</ul>
<h2 id="14_2-操作系统体系结构下">1.4_2 操作系统体系结构(下)</h2>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.16.05.png" alt=""></p>
<h2 id="15-操作系统的引导">1.5 操作系统的引导</h2>
<ul>
<li>什么是操作系统引导</li>
<li>磁盘里有哪些相关数据
<ul>
<li>磁盘
<ul>
<li>主引导记录(MBR)，包含磁盘引导程序和分区表</li>
<li>C盘，是这个磁盘的活动分区，安装了操作系统
<ul>
<li>引导记录PBR(负责找到启动管理器)</li>
<li>根目录</li>
<li>其他</li>
</ul>
</li>
<li>D盘</li>
<li>E盘</li>
<li>F盘</li>
</ul>
</li>
<li>CPU
<ul>
<li>RAM，会因断电而流失</li>
<li>ROM(BIOS基本输入输出系统) 包含：ROM引导程序，即自举程序，不会因为断电而流失</li>
</ul>
</li>
</ul>
</li>
<li>开机过程
<ul>
<li>开机后，从一个特定贮存地址开始，取指令，执行ROM引导程序(先进行硬件自检，再开机)</li>
<li>将磁盘的第一块——主引导记录MBR读入内存，执行磁盘引导程序，扫描分区表</li>
<li>从活动分区(又称主分区，即安装了操作系统的分区)读入分区引导记录，执行其中的程序PBR</li>
<li>从根目录下找到完整的操作系统初始化程序(即启动管理器)并执行，完成“开机”的一系列操作</li>
</ul>
</li>
</ul>
<h2 id="16-虚拟机">1.6 虚拟机</h2>
<ul>
<li>传统计算机
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.47.43.png" alt=""></li>
<li>虚拟机
<ul>
<li>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器(VM)，每个虚拟机器都可以独立运行一个操作系统</li>
<li>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor</li>
</ul>
</li>
<li>虚拟机管理程序
<ul>
<li>第一类虚拟机管理程序
<ul>
<li>上层操作系统运行虚拟内核空间</li>
</ul>
</li>
<li>第二类操作系统
<ul>
<li>在宿主操作系统之上安装并启动多个操作系统
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.54.43.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>两类虚拟机管理程序(VMM)的对比
<img src="/images/%E6%88%AA%E5%B1%8F2024-09-12%2009.55.55.png" alt=""></li>
</ul>
<h1 id="第二章-进程管理">第二章 进程管理</h1>
<h2 id="21_1-进程的概念组成特征">2.1_1 进程的概念、组成、特征</h2>
<ul>
<li>进程的概念
<ul>
<li>程序：静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合</li>
<li>进程：是动态的，是程序的一次执行过程(同一个程序多次执行会对应多个进程)</li>
</ul>
</li>
<li>进程实体的组成
<ul>
<li>PCB</li>
<li>程序段</li>
<li>数据段</li>
</ul>
</li>
<li>进程控制块(PCB)
<ul>
<li>给操作系统使用</li>
<li><strong>进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB</li>
<li>需保存的信息
<ul>
<li>进程描述信息(进程标识符PID，用户标识符PID)</li>
<li>进程控制和管理信息(CPU、磁盘、网络流量使用情况统计，进程当前状态：就绪态/阻塞态/运行态)</li>
<li>资源分配清单(正在使用哪些文件，正在使用哪些内存区域，正在使用哪些I/O设备)</li>
<li>处理机相关信息(PSW、PC等等各种寄存器的值，用于实现进程切换)</li>
</ul>
</li>
<li>操作系统对进程进行管理工作所需的信息都保存在PCB中</li>
</ul>
</li>
<li>程序段
<ul>
<li>程序的代码(指令序列)</li>
</ul>
</li>
<li>数据段
<ul>
<li>运行过程中产生的各种数据，如：程序中定义的变量</li>
</ul>
</li>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li>
<li>一个进程被“调度”，就是指操作系统决定让这个进程上CPU运行</li>
<li>同时挂三个QQ号，会对应三个QQ进程，它们的PCB、数据段各不相同，但程序段的内容都是相通的(都是运行着相同的QQ程序)</li>
<li>进程的特征
<ul>
<li>动态性
<ul>
<li>进程最基本的特征</li>
<li>进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
</ul>
</li>
<li>并发性
<ul>
<li>内存中有多个进程实体，各进程可并发执行</li>
</ul>
</li>
<li>独立性
<ul>
<li>进程是能独立运行、独立获得资源、独立接收调度的基本单位</li>
</ul>
</li>
<li>异步性
<ul>
<li>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题</li>
<li>会导致进程执行结果的不一致性</li>
</ul>
</li>
<li>结构性
<ul>
<li>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-6">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-09-23%2022.41.35.png" alt=""></p>
<h2 id="21_2-进程的状态与转换进程的组织">2.1_2 进程的状态与转换、进程的组织</h2>
<h3 id="进程的状态">进程的状态</h3>
<ul>
<li>可执行文件存储在硬盘中</li>
<li>程序执行时，可执行文件被调入内存，操作系统建立PCB(进程)-&gt;进程正在被创建时，它的状态是“<strong>创建态</strong>”，在这个阶段操作系统会为进程分配资源、初始化PCB</li>
<li>进程创建完成之后，便进入“<strong>就绪态</strong>”，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行</li>
<li>当CPU空闲时，操作系统就会选择一个就绪进程，让它上处理机运行。如果一个进程此时在CPU上运行，那么这个进程处于“<strong>运行态</strong>”，CPU会执行该进程对应的程序(执行指令序列)</li>
<li>在进程运行的过程中，可能会请求等待某个事件的发生(如等待某种系统资源的分配，或者等待其他进程的响应)，在这个事件发生之前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入“<strong>阻塞态</strong>”，当CPU空闲时，又会选择另一个“就绪态”进程上CPU</li>
<li>一个进程可以执行exit系统调用，请求操作系统终止该进程，此时该进程会进入“<strong>终止态</strong>”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB，当中止进程的工作完成之后，这个进程就彻底消失了
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.40.48.png" alt=""></li>
</ul>
<h3 id="进程状态的转换">进程状态的转换</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.37.47.png" alt=""></p>
<h3 id="进程的组织">进程的组织</h3>
<ul>
<li>链接方式
<ul>
<li>执行指针 指向当前处于运行态(执行态)的进程</li>
<li>就绪队列指针 指向当前处于就绪态的进程</li>
<li>阻塞队列指针 指向当前处于阻塞态的进程
<ul>
<li>等待打印机的阻塞队列</li>
<li>等待磁盘的阻塞队列
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.44.31.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>索引方式
<ul>
<li>执行指针</li>
<li>就绪表指针</li>
<li>阻塞表指针
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.45.14.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="总结-7">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-10%2010.45.59.png" alt=""></p>
<h2 id="21_3-进程控制">2.1_3 进程控制</h2>
<h3 id="什么是进程控制">什么是进程控制</h3>
<ul>
<li>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</li>
<li>简化理解：实现进程状态转换
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-19%2020.56.49.png" alt=""></li>
</ul>
<h3 id="如何实现进程控制">如何实现进程控制</h3>
<ul>
<li>通过原语实现
<ul>
<li>一种特殊的程序</li>
<li>执行具有原子性</li>
<li>运行必须一气呵成，不可中断</li>
</ul>
</li>
<li>为何进程控制(状态转换)的过程要“一气呵成”
<ul>
<li>发生状态转换时，负责进程控制的内核程序至少需要做两件事
<ul>
<li>state改变</li>
<li>移动PCB2从一个队列到另一个队列</li>
</ul>
</li>
<li>如果不能“一气呵成”，就有可能导致操作系统中某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</li>
</ul>
</li>
</ul>
<h3 id="如何实现原语的原子性">如何实现原语的“原子性”</h3>
<ul>
<li>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断</li>
<li>可以用“关中断指令”和“开中断指令”这两个特权指令实现原子性</li>
</ul>
<blockquote>
<p>正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序
CPU执行了关中断指令之后，就不再例行检查中断信号，直到执行开中断指令之后才会恢复检查-&gt;这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”</p>
</blockquote>
<ul>
<li>如果这两个特权指令允许用户程序使用的话，会发生什么情况？
<ul>
<li>关中断指令和开中断指令是特权指令，只能让内核程序使用，不能让普通用户程序使用</li>
</ul>
</li>
</ul>
<h3 id="进程控制相关的原语">进程控制相关的原语</h3>
<ul>
<li>进程的创建
<ul>
<li>创建原语(操作系统创建一个进程时使用的原语)
<ul>
<li>申请空白PCB</li>
<li>为新进程分配所需资源</li>
<li>初始化PCB</li>
<li>将PCB插入就绪队列(<strong>创建态-&gt;就绪态</strong>)</li>
</ul>
</li>
<li>引起进程创建的事件
<ul>
<li>用户登录 分时系统中，用户登录成功，系统会为其建立一个新的进程</li>
<li>作业调度 多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务 用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求 由用户进程主动请求创建一个子进程</li>
</ul>
</li>
</ul>
</li>
<li>进程的终止
<ul>
<li>撤销原语(<strong>就绪态/阻塞态/运行态-&gt;终止态-&gt;无</strong>)
<ul>
<li>从PCB集合中找到终止进程的PCB</li>
<li>若进程正在运行，立即剥夺CPU，将CPU分配给其他进程</li>
<li>终止其所有子进程(进程间的关系是树形结构)</li>
<li>将该进程拥有的所有资源归还给父进程或操作系统</li>
<li>删除PCB</li>
</ul>
</li>
<li>引起进程终止的事件
<ul>
<li>正常结束(进程自己请求终止，exit系统调用)</li>
<li>异常结束(整数除以0、非法使用特权指令，然后被操作系统强行杀掉)</li>
<li>外界干预(Ctrl + Alt + delete，用户选择杀掉进程)</li>
</ul>
</li>
</ul>
</li>
<li>进程的阻塞
<ul>
<li>阻塞原语(<strong>运行态-&gt;阻塞态</strong>)
<ul>
<li>找到要阻塞的进程对应的PCB</li>
<li>保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行</li>
<li>将PCB插入相应事件的等待队列</li>
</ul>
</li>
<li>引起进程阻塞的事件
<ul>
<li>需要等待系统分配某种资源</li>
<li>需要等待相互合作的其他进程完成工作</li>
</ul>
</li>
</ul>
</li>
<li>进程的唤醒
<ul>
<li>唤醒原语(<strong>阻塞态-&gt;就绪态</strong>)
<ul>
<li>在事件等待队列中找到PCB</li>
<li>将PCB从等待队列中移除，设置进程为就绪态</li>
<li>将PCB插入就绪队列，等待被调度</li>
</ul>
</li>
<li>引起进程唤醒的事件
<ul>
<li>等待的事件发生(因何事阻塞，就该由何事唤醒)</li>
</ul>
</li>
<li>唤醒原语和阻塞原语必须成对使用</li>
</ul>
</li>
<li>进程的切换
<ul>
<li>切换原语(运行态-&gt;就绪态/就绪态-&gt;运行态)
<ul>
<li>将运行环境存入PCB</li>
<li>PCB移入相应队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>根据PCB恢复新进程所需的运行环境</li>
</ul>
</li>
<li>引起进程切换的事件
<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-8">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-19%2022.31.39.png" alt=""></p>
<h2 id="21_4-进程通信ipc">2.1_4 进程通信(IPC)</h2>
<ul>
<li>什么是进程间通信？
<ul>
<li>IPC, 两个进程之间产生数据交互</li>
</ul>
</li>
<li>为什么进程通信需要操作系统支持
<ul>
<li>进程是分配系统资源的单位(包括内存地址空间)，因此各进程拥有的内存地址空间相互独立</li>
</ul>
</li>
</ul>
<h3 id="共享存储">共享存储</h3>
<ul>
<li>进程可以申请共享存储区，也可以供其他进程使用</li>
<li>Linux
<ul>
<li>int shm_open(&hellip;); // 通过shm_open系统调用，申请一片共享内存区</li>
<li>void * mmap(&hellip;);  // 通过mmap系统调用，将共享内存区映射到进程自己的地址空间</li>
</ul>
</li>
<li>通过“增加页表项/段表项”即可将同一片共享内存去映射到各个进程的地址空间中</li>
<li>为避免出错，各个进程对共享空间的访问应该是互斥的</li>
<li>各个<strong>进程</strong>可使用操作系统内核提供的同步互斥工具(如P、V操作)</li>
<li>基于存储区的共享
<ul>
<li>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都<strong>由通信进程控制</strong>，而不是操作系统。</li>
<li>这种共享方式速度很快，是一种高级通信方式</li>
</ul>
</li>
<li>基于数据结构的共享
<ul>
<li>共享空间里只能放一个长度为10的数组</li>
<li>这种共享方式速度慢、限制多，是一种低级通信方式</li>
</ul>
</li>
</ul>
<h3 id="消息传递">消息传递</h3>
<ul>
<li>进程间的数据交换以格式化的消息(Message)为单位</li>
<li>进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换</li>
</ul>
<h4 id="消息结构">消息结构</h4>
<ul>
<li>消息头
<ul>
<li>发送进程ID</li>
<li>接收进程ID</li>
<li>消息长度等格式化信息</li>
</ul>
</li>
</ul>
<h4 id="消息传递方式">消息传递方式</h4>
<ul>
<li>直接通信方式
<ul>
<li>消息发送进程要指明接收进程的ID
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2009.45.19.png" alt=""></li>
</ul>
</li>
<li>间接通信方式
<ul>
<li>通过“信箱”间接地通信，因此又称“信箱通信方式”
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2009.44.22.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="管道通信">管道通信</h3>
<ul>
<li>通过pipe文件进行通信
<ul>
<li>“管道”是一个特殊的共享文件，又名pipe文件</li>
<li>其实就是在内存中开辟一个大小固定的内存缓冲区</li>
</ul>
</li>
<li>只能一个进程写、一个进程读，单向</li>
<li>先进先出FIFO</li>
<li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个短道</li>
<li>各进程要互斥地访问管道(由<strong>操作系统实现</strong>)</li>
<li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程</li>
<li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程</li>
<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程度读同一个管道时，可能会错乱
<ul>
<li>一个管道允许多个写进程，一个读进程</li>
<li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据(Linux的方案)</li>
</ul>
</li>
</ul>
<h3 id="总结-9">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.09.13.png" alt=""></p>
<h2 id="21_5-线程的概念">2.1_5 线程的概念</h2>
<h3 id="什么是线程为什么要引入线程">什么是线程，为什么要引入线程</h3>
<ul>
<li>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序</li>
<li>为此，引入了“线程”来增加并发度</li>
<li>程序执行流的最小单位
<ul>
<li>传统的进程是程序执行流的最小单位</li>
<li>引入线程后，线程成为了程序执行流的最小单位</li>
</ul>
</li>
<li>可以把线程理解为“轻量级进程”</li>
<li>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</li>
<li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发读，使得一个进程内也可以并发处理各种任务(如QQ视频、文字聊天、传文件)</li>
<li>引入线程后，进程只作为除CPU之外的系统资源的分配单元(如打印机、内存地址空间等都是分配给进程的)</li>
<li>带来的变化
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.20.50.png" alt=""></li>
</ul>
<h3 id="线程的属性">线程的属性</h3>
<ul>
<li>线程是处理机调度的单位</li>
<li>多CPU计算机中，各个线程可占用不同的CPU</li>
<li>每个线程都有一个线程ID、线程控制模块(TCB)</li>
<li>线程也有就绪、阻塞、运行三种基本状态</li>
<li>线程几乎不拥有系统资源</li>
<li>同一进程的不同线程间共享进程的资源</li>
<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>
<li>同一进程中的线程切换，不会引起进程切换</li>
<li>不同进程中的线程切换，会引起进程切换</li>
<li>切换同进程内的线程，系统开销很小</li>
<li>切换进程，系统开销较大</li>
</ul>
<h2 id="21_6-线程的实现方式和多线程模式">2.1_6 线程的实现方式和多线程模式</h2>
<h3 id="线程的实现方式">线程的实现方式</h3>
<ul>
<li>用户级线程ULT
<ul>
<li>早期的操作系统(如早期Unix)只支持进程，不支持线程</li>
<li>当时的“线程”是由线程库实现的
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.26.55.png" alt=""></li>
<li>很多编程语言提供了大量线程库，可以实现线程的创建、销毁、调度等功能</li>
<li>特点
<ul>
<li>用户级线程由应用程序通过线程库来实现，所有的线程切换工作都由应用程序负责(包括线程切换)</li>
<li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</li>
<li>在用户看来，是有多个线程。但是在操作系统内核看来，意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</li>
<li>优缺点
<ul>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞时，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>内核级线程KLT
<ul>
<li>大多数现代操作系统都实现了内核级线程</li>
<li>又称为“内核支持的线程”，是由操作系统支持的线程</li>
<li>特点
<ul>
<li>内核级线程的管理工作由操作系统内核完成</li>
<li>线程调度、切换等工作由内核负责，因此内核线程的切换必然需要在核心态下才能完成</li>
<li>操作系统会为每个内核级线程建立相应的TCB(Thread Control Block， 线程控制块)，通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角能看得到的线程”</li>
<li>优缺点
<ul>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并发执行</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多线程模型
<ul>
<li>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为集中多线程模型</li>
<li>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级进程
<ul>
<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li>
<li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>
</ul>
</li>
<li>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配到一个内核级线程
<ul>
<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到和心态，线程管理的系统开销小，效率高</li>
<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>
</ul>
</li>
</ul>
</li>
<li>多对多模型
<ul>
<li>n用户级线程映射到m个内核级线程(n &gt;= m)。每个用户进程对应m个内核级线程</li>
<li>克服了多对一模型并发读不高的缺点(一个阻塞全体阻塞)，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li>
</ul>
</li>
</ul>
<h3 id="总结-10">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.49.42.png" alt=""></p>
<h2 id="21_7-进程的状态与转换">2.1_7 进程的状态与转换</h2>
<h3 id="状态与转换">状态与转换</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2010.56.13.png" alt=""></p>
<h3 id="组织与控制">组织与控制</h3>
<ul>
<li>组织
<ul>
<li>TCB(线程控制块)</li>
<li>线程表
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2011.01.35.png" alt=""></li>
</ul>
</li>
<li>控制
<ul>
<li>状态转换</li>
</ul>
</li>
</ul>
<h2 id="22_1-处理机调度的概念层次">2.2_1 处理机调度的概念、层次</h2>
<h3 id="基本概念">基本概念</h3>
<ul>
<li>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题</li>
</ul>
<h3 id="调度的三个层次">调度的三个层次</h3>
<ul>
<li>高级调度
<ul>
<li>作业：一个具体的任务=&gt;用户向操作系统提交一个作业～用户让操作系统启动一个程序(来处理一个具体的任务)</li>
<li>高级调度(作业调度)
<ul>
<li>按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程</li>
<li>每个作业只调入依次，调出一次</li>
<li>作业调入式会建立PCB，调出时才撤销PCB</li>
</ul>
</li>
</ul>
</li>
<li>低级调度(进程调度/处理机调度)
<ul>
<li>按照某种策略从就绪队列中选取一个进程，将处理机分配给它</li>
<li>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度</li>
<li>进程调度的频率很高，一般几十毫米一次</li>
</ul>
</li>
<li>中级调度
<ul>
<li>内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存</li>
<li>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织或挂起队列</li>
<li>中级调度(内存调度) ——按照某种策略决定将哪个处于挂起状态的进程重新调入内存</li>
</ul>
</li>
<li>补充知识：进程的挂起态与七状态模型
<ul>
<li>暂时调到外存等待的进程状态称为挂起状态</li>
<li>挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</li>
<li>五状态模型-&gt;七状态模型
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.22.48.png" alt=""></li>
</ul>
</li>
<li>三种调度的联系、对比
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.26.09.png" alt=""></li>
</ul>
<h3 id="总结-11">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.27.47.png" alt=""></p>
<h2 id="22_2-进程调度的时机切换与过程方式">2.2_2 进程调度的时机、切换与过程、方式</h2>
<h3 id="进程调度的时机">进程调度的时机</h3>
<ul>
<li>进程调度(低级调度)，就是按照某种算法从就绪队列中选择一个进程为其分配处理机</li>
<li>需要进程进程的调度与切换的情况
<ul>
<li>当前运行的进程主动放弃处理机
<ul>
<li>进程正常终止</li>
<li>运行过程中发生异常而终止</li>
<li>进程主动请求阻塞(如等待I/O)</li>
</ul>
</li>
<li>当前运行的进程被动放弃处理机
<ul>
<li>分给进程的时间片用完</li>
<li>有更紧急地事情需要处理(如I/O中断)</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
</li>
<li>不能进行进程调度与切换的情况
<ul>
<li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中</li>
<li>在原子操作过程中(原语)。原子操作不可中断，要一气呵成(如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列)</li>
</ul>
</li>
<li>进程在操作系统的内核临界区中不能进行调度与切换
<ul>
<li>临界资源
<ul>
<li>一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源</li>
</ul>
</li>
<li>临界区：访问临界资源的那段代码</li>
<li>内核程序临界区
<ul>
<li>一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)</li>
</ul>
</li>
<li>在进行进程调度与切换时，需要访问临界资源，如果进程还没有退出临界区，进程调度相关程序就无法访问临界资源</li>
<li>但普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此在访问<strong>普通临界区时可以进行调度与切换</strong></li>
</ul>
</li>
</ul>
<h3 id="进程调度的方式">进程调度的方式</h3>
<ul>
<li>非剥夺调度方式
<ul>
<li>又称非抢占方式</li>
<li>只允许进程主动放弃处理机</li>
<li>在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</li>
<li>实现简单，系统开销小但无法及时处理紧急任务，适合于早期的批处理系统</li>
</ul>
</li>
<li>剥夺调度方式
<ul>
<li>又称抢占方式</li>
<li>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要更紧迫的那个进程</li>
<li>可以优先处理更紧急的进程，也可实现让个进程按时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统</li>
</ul>
</li>
</ul>
<h3 id="进程的切换与过程">进程的切换与过程</h3>
<ul>
<li>“狭义的进程调度”与“进程切换”的区别
<ul>
<li>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)</li>
<li>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</li>
</ul>
</li>
<li>广义的进程调度包含了选择一个进程和进程切换两个步骤</li>
<li>进程切换的过程主要完成了
<ul>
<li>对原来运行进程各种数据的保存</li>
<li>对新的进程各种数据的恢复(如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块)</li>
</ul>
</li>
<li>注意：进程切换是有代价的，因此如果过于频繁的进程进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</li>
</ul>
<h3 id="总结-12">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-21%2018.49.58.png" alt=""></p>
<h2 id="22_3-调度器和闲逛进程">2.2_3 调度器和闲逛进程</h2>
<h3 id="调度程序决定">调度程序决定</h3>
<ul>
<li>就绪态与运行态之间的转换</li>
<li>让谁运行
<ul>
<li>调度算法</li>
</ul>
</li>
<li>运行多长时间
<ul>
<li>时间片大小</li>
</ul>
</li>
</ul>
<h3 id="调度时机">调度时机</h3>
<ul>
<li>创建新进程</li>
<li>进程退出</li>
<li>运行进程阻塞</li>
<li>I/O中断发生(可能唤醒某些阻塞进程)</li>
<li>非抢占式调度策略，只有运行进程阻塞或退出才出发调度程序工作</li>
<li>抢占式调度策略，每个时钟中断或k个时钟中断会触发调度程序工作</li>
</ul>
<h3 id="调度程序的处理对象">调度程序的处理对象</h3>
<ul>
<li>不支持内核级线程的操作系统，调度程序的处理对象是进程</li>
<li>支持内核级线程的操作系统，调度程序的处理对象是内核线程</li>
</ul>
<h3 id="闲逛进程">闲逛进程</h3>
<ul>
<li>没有其他就绪进程时，运行闲逛进程(idle)</li>
<li>特性
<ul>
<li>优先级最低</li>
<li>可以是0地址指令，占一个完整的指令周期(指令周期末尾例行检查中断)</li>
<li>能耗低</li>
</ul>
</li>
</ul>
<h2 id="22_4-调度算法的评价指标">2.2_4 调度算法的评价指标</h2>
<h3 id="cpu利用率">CPU利用率</h3>
<ul>
<li>希望让CPU尽可能多地工作</li>
<li>CPU利用率：CPU &ldquo;忙碌&quot;的时间占总时间的比例</li>
<li>利用率 = 忙碌的时间/总时间</li>
</ul>
<h3 id="系统吞吐量">系统吞吐量</h3>
<ul>
<li>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业</li>
<li>系统吞吐量：单位时间内完成作业的数量</li>
<li>系统吞吐量：总共完成了多少道作业/总共花了多少时间</li>
</ul>
<h3 id="周转时间">周转时间</h3>
<ul>
<li>从作业被提交给程序开始，到作业完成为止的这段时间间隔</li>
<li>组成部分
<ul>
<li>作业在外存后备队列上等待作业调度的时间(高级调度)</li>
<li>进程在就绪队列上等待进程调度(低级调度)的时间占总时间</li>
<li>进程在CPU上的执行时间</li>
<li>进程等待I/O操作完成的时间</li>
</ul>
</li>
</ul>
<h2 id="22_5-调度算法1">2.2_5 调度算法(1)</h2>
<h3 id="先来先服务fcfs"><strong>先来先服务(FCFS)</strong></h3>
<ul>
<li>算法思想
<ul>
<li>主要从“公平”的角度考虑</li>
</ul>
</li>
<li>算法规则
<ul>
<li>按照作业/进程到达的先后顺序进行服务</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后被队列</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>非抢占式算法</li>
</ul>
</li>
</ul>
<blockquote>
<p>周转时间 = 完成时间 - 到达时间
带权周转时间 = 周转时间 / 运行时间
等待时间 = 周转时间 - 运行时间( - I/O操作时间)</p>
</blockquote>
<ul>
<li>优缺点
<ul>
<li>优点：公平、算法实现简单</li>
<li>缺点：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好(FCFS算法对长作业有利，对短作业不利)</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="短作业优先sjf"><strong>短作业优先(SJF)</strong></h3>
<ul>
<li>算法思想
<ul>
<li>追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</li>
<li>选择当前已到达且运行时间最短的作业/进程</li>
</ul>
</li>
<li>算法规则
<ul>
<li>最短的作业/进程优先得到服务(要求服务时间最短)</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>既可用于作业调度，也可用于进程调度</li>
<li>用于进程调度时称为“<strong>短进程优先(SPF)算法</strong>”</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>SJF和SPF是<strong>非抢占式</strong>的算法。但也有抢占式的版本——<strong>最短剩余时间优先算法(SRTN)</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p>最短剩余时间优先算法：
每当有进程加入，就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。
当一个进程完成时也需要调度</p>
</blockquote>
<ul>
<li>注意细节
<ul>
<li>默认是非抢占式的</li>
<li>相比于其他算法(如FCFS), SJF可以获得较少的平均等待时间、平均周转时间</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：“最短的”平均等待时间、平均周转时间</li>
<li>缺点：不公平。对短作业有利，对长作业不利，可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</li>
</ul>
</li>
</ul>
<h3 id="高响应比优先hrrn"><strong>高响应比优先(HRRN)</strong></h3>
<ul>
<li>算法思想
<ul>
<li>要综合考虑作业/进程的等待时间和要求服务的时间</li>
</ul>
</li>
<li>算法规则
<ul>
<li>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务</li>
<li>如果响应比相等，则等待时间长者优先</li>
</ul>
</li>
</ul>
<blockquote>
<p>响应比 = (等待时间 + 要求服务时间) / 要求服务时间
响应比 ≥ 1</p>
</blockquote>
<ul>
<li>用于作业/进程调度
<ul>
<li>既可用于作业调度，也可用于进程调度</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：综合考虑了等待时间和运行时间(要求服务时间)
<ul>
<li>等待时间相同时，要求服务时间短的优先(SJF的优点)</li>
<li>要求服务时间相同时，等待时间常德优先(FCFS的优点)</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>
</ul>
</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="总结-13">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2019.46.10.png" alt=""></p>
<h2 id="22_6-调度算法2">2.2_6 调度算法(2)</h2>
<h3 id="时间片轮转调度算法rr">时间片轮转调度算法(RR)</h3>
<ul>
<li>算法思想
<ul>
<li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>
<li>伴随着分时操作系统的诞生而诞生</li>
</ul>
</li>
<li>算法规则
<ul>
<li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片(如100ms)</li>
<li>若进程未在一个时间片内执行完成，则剥夺处理机，将进程重新放回到就绪队列队尾重新排序</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法</li>
<li>由时钟装置发出时钟中断来通知CPU时间片已到</li>
</ul>
</li>
<li>注意
<ul>
<li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间，因此时间片不能太大</li>
<li>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会话大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。(一般来说，设计时间片时要让切换进程的开销占比不超过1%)</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：公平；响应快，适于分时操作系统</li>
<li>缺点：由于高频率的进程切换，因此会有一定开销；不区分任务的紧急程度</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>不会</li>
</ul>
</li>
</ul>
<h3 id="优先级调度算法">优先级调度算法</h3>
<ul>
<li>算法思想
<ul>
<li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>
</ul>
</li>
<li>算法规则
<ul>
<li>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>既可用于作业调度，也用于进程调度。甚至，还会用于在之后会学习的I/O调度中</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>抢占式、非抢占式都有</li>
<li><strong>非抢占式</strong>只需在进<strong>程主动放弃处理机时</strong>进行调度即可，而<strong>抢占式</strong>还需在<strong>就绪队列变化时</strong>，检查是否会发生抢占</li>
</ul>
</li>
<li>补充
<ul>
<li>就绪队列未必只有一个，可以按照不同优先级来组织；另外，也可以把优先级高的进程排在更靠近队头的位置</li>
<li>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种</li>
</ul>
</li>
</ul>
<blockquote>
<p>静态优先级：创建进程时确定，之后一直不变
动态优先级：创建进程时有一个初始值，之后会根据情况动态地去调整优先级</p>
</blockquote>
<ul>
<li>通常：系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更偏好I/O进程(I/O繁忙进程)</li>
</ul>
<blockquote>
<p>I/O设备和CPU可以并行工作。如果有先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升
与I/O型进程相对的是计算型进程(或称CPU繁忙型进程)</p>
</blockquote>
<ul>
<li>动态优先级如何调整
<ul>
<li>可以从追求公平、提升资源利用率等角度考虑</li>
<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级(如高响应比优先算法)</li>
<li>如果某进程占用处理机运行了很长时间，则可以适当降低其优先级</li>
<li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度</li>
<li>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>会</li>
</ul>
</li>
</ul>
<h3 id="多级反馈队列调度算法">多级反馈队列调度算法</h3>
<ul>
<li>算法思想
<ul>
<li>对其他调度算法的折中权衡</li>
</ul>
</li>
<li>算法规则
<ul>
<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>
<li>新进程到达时先进入第1级队列，按FCFS原则排队等待分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li>
<li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li>
<li>被抢占处理机的进程重新放回原队列队尾</li>
</ul>
</li>
<li>用于作业/进程调度
<ul>
<li>用于进程调度</li>
</ul>
</li>
<li>是否可抢占？
<ul>
<li>抢占式算法</li>
<li>在k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾</li>
</ul>
</li>
<li>优缺点
<ul>
<li>优点
<ul>
<li>对各类进程相对公平(FCFS的优点)；</li>
<li>每个新到达的进程都可以很快就得到响应(RR的优点)；</li>
<li>短进程只用较少的时间就可以完成(SPF的优点)；</li>
<li>不必实现估计进程的运行时间(避免用户作假)；</li>
<li>可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展:可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级)</li>
</ul>
</li>
</ul>
</li>
<li>是否会导致饥饿
<ul>
<li>会</li>
</ul>
</li>
</ul>
<h3 id="总结-14">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2021.11.04.png" alt=""></p>
<h2 id="22_7-调度算法3">2.2_7 调度算法(3)</h2>
<h3 id="多级队列调度算法">多级队列调度算法</h3>
<ul>
<li>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</li>
<li>进程分类
<ul>
<li>系统进程(如内存管理进程) 优先级最高</li>
<li>交互式进程(如游戏、打字软件)</li>
<li>批处理进程(如AI模型训练、视频特效渲染) 优先级最低</li>
</ul>
</li>
<li>固定优先级/时间片划分
<ul>
<li>固定优先级
<ul>
<li>高优先级空时第优先级进程才被调度</li>
</ul>
</li>
<li>时间片划分
<ul>
<li>如三个队列分配时间50%, 40%, 10%</li>
</ul>
</li>
</ul>
</li>
<li>各队列可采用不同的调度策略
<ul>
<li>系统进程队列采用优先级调度</li>
<li>交互式队列采用RR</li>
<li>批处理队列采用FCFS</li>
<li>按实际情况来定</li>
</ul>
</li>
</ul>
<h2 id="23_1-进程同步进程互斥">2.3_1 进程同步、进程互斥</h2>
<h3 id="什么是进程同步">什么是进程同步</h3>
<blockquote>
<p>知识点回顾：进程具有异步性的特征
异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进
管道通信中，读进程与谢进程并发地运行，由于并发必然导致<strong>异步性</strong>，因此“写数据”和“读数据”两个操作执行的先后顺序是不确定的；而实际应用中，又必须按照“写数据-&gt;读数据“的顺序来执行的
如何解决这种异步问题，就是“进程同步”所讨论的内容</p>
</blockquote>
<ul>
<li>同步亦称<strong>直接制约关系</strong>，它是指未完成某种任务而尽力的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作</li>
</ul>
<h3 id="什么是进程互斥">什么是进程互斥</h3>
<ul>
<li>进程的“并发”需要“共享”支持，各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机、摄像头这样的I/O设备)</li>
<li>两种资源共享方式
<ul>
<li>互斥共享方式
<ul>
<li>系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</li>
</ul>
</li>
<li>同时共享方式
<ul>
<li>系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>临界资源：一个时间段内只允许一个进程使用的资源
互斥：亦称简介制约关系。对临界资源的访问，必须互斥的进行
进程互斥：当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p>
</blockquote>
<ul>
<li>对临界资源的互斥访问，可以在逻辑上分为如下四个部分
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">entry</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 进入区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">exit</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 退出区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">reminder</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 剩余区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
</span></span></code></pre></div><ul>
<li>进入区
<ul>
<li>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志(可理解为“上锁”)，以阻止其他进程同时进入临界区</li>
</ul>
</li>
<li>临界区(临界段)
<ul>
<li>访问临界资源的那段代码</li>
</ul>
</li>
<li>退出区
<ul>
<li>负责解除正在访问临界资源的标志(可理解为“解锁”)</li>
</ul>
</li>
<li>剩余区
<ul>
<li>做其他处理</li>
</ul>
</li>
</ul>
</li>
<li>原则
<ul>
<li>空闲让进
<ul>
<li>临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>
</ul>
</li>
<li>忙则等待
<ul>
<li>当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>
</ul>
</li>
<li>有限等待
<ul>
<li>对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li>
</ul>
</li>
<li>让权等待
<ul>
<li>当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>忙等待：进程暂时无法往下推进，但一直占用处理机</p>
</blockquote>
<h3 id="总结-15">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2021.52.24.png" alt=""></p>
<h2 id="23_2-进程互斥的软件实现方法">2.3_2 进程互斥的软件实现方法</h2>
<h3 id="单标志法">单标志法</h3>
<ul>
<li>算法思想
<ul>
<li>一个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// turn 表示当前允许进入临界区的进程号码
</span></span></span><span class="line"><span class="cl"><span class="c1">// P0进程：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">turn</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>  <span class="c1">// 进入区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>   <span class="c1">// 临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>           <span class="c1">// 退出区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>  <span class="c1">// 剩余区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 该算法可以实现“同一时刻最多只允许一个进程访问临界区”
</span></span></span></code></pre></div></li>
<li>主要问题
<ul>
<li>违背“空闲让进”原则</li>
</ul>
</li>
</ul>
<h3 id="双标志先检查">双标志先检查</h3>
<ul>
<li>算法思想
<ul>
<li>设置一个布尔型数组flag[]，数组中各个元素用来标记个<strong>进程想进入临界区的意愿</strong>，比如&quot;flag[0] = true&rdquo;，意味着0号进程P0现在想要进入临界区。</li>
<li>每个进程在进入临界区之前先<strong>检查</strong>当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 表示进入临界区意愿的数组
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 刚开始设置为两个进程都不想进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 如果此时P0想进入临界区，P1就一直循环等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记为P1进程想要进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 访问临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 访问完临界区，修改标记为P1不想使用临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>主要问题：违反“忙则等待”原则
<ul>
<li>原因：进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换</li>
</ul>
</li>
</ul>
<h3 id="双标志后检查">双标志后检查</h3>
<ul>
<li>算法思想
<ul>
<li>双标志先检查法的改版，先“上锁”后“检查”</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 标记为P1进程想要进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// 如果此时P0想进入临界区，P1就一直循环等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">critical</span> <span class="n">section</span><span class="p">;</span> <span class="c1">// 访问临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// 访问完临界区，修改标记为P1不想使用临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>问题
<ul>
<li>虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象</li>
</ul>
</li>
</ul>
<h3 id="peterson算法">Peterson算法</h3>
<ul>
<li>算法思想
<ul>
<li>结合双标志法、单标志法的思想</li>
<li>如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”(谦让)，做一个有礼貌的进程</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>  <span class="c1">// 表示进入临界区意愿的数组，初始值都是false(背后的含义：“表达意愿”)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// turn 表示优先让哪个进程进入临界区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">turn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">critical</span> <span class="n">section</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">remainder</span> <span class="n">section</span><span class="p">;</span>
</span></span></code></pre></div></li>
<li>优点
<ul>
<li>用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则</li>
</ul>
</li>
<li>缺点
<ul>
<li>依然未遵循让权等待原则
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2022.29.12.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="23_3-进程互斥的硬件实现方法">2.3_3 进程互斥的硬件实现方法</h2>
<h3 id="中断屏蔽方法">中断屏蔽方法</h3>
<ul>
<li>利用“开/关中断指令”实现</li>
<li>进程访问临界区之前，关中断</li>
<li>进程访问完金街区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</li>
<li>优点：简单、搞笑</li>
<li>缺点：不适用于多处理机；知识用于操作系统内核进程，不适用于内核进程</li>
</ul>
<blockquote>
<p>因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险</p>
</blockquote>
<h3 id="testandset指令">TestAndSet指令</h3>
<ul>
<li>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令</li>
<li>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</li>
<li>逻辑(实际上是由硬件实现)</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// 布尔型共享变量lock表示当前临界区是否被加锁
</span></span></span><span class="line"><span class="cl"><span class="c1">// true表示已加锁，false表示未加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="nf">TestAndSet</span> <span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">bool</span> <span class="n">old</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span> <span class="c1">// old用来存放lock原来的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 无论之前是否已加锁，都将lock设为true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">return</span> <span class="n">old</span><span class="p">;</span> <span class="c1">// 返回lock原来的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以下是使用TSL指令实现互斥的算法逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="n">TestAndSet</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">));</span> <span class="c1">// “上锁”并“检查”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">临界区代码段</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//“解锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">剩余代码段</span><span class="p">...</span>
</span></span></code></pre></div><ul>
<li>优点
<ul>
<li>TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</li>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li>
</ul>
</li>
<li>缺点
<ul>
<li>不满足“让权等待”的原则</li>
</ul>
</li>
</ul>
<h3 id="swap指令">Swap指令</h3>
<ul>
<li>有的地方也叫Exchange指令，或简称XCHG指令</li>
<li>用硬件实现，执行的过程不允许被中断，只能一气呵成</li>
<li>逻辑</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="c1">// Swap指令的作用是交换两个变量的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Swap</span> <span class="p">(</span><span class="kt">bool</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">boo</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 以下是用Swap指令实现互斥的算法逻辑
</span></span></span><span class="line"><span class="cl"><span class="c1">// lock表示当前临界区是否被加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">bool</span> <span class="n">old</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">while</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">Swap</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">old</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">临界区代码</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="err">剩余区代码段</span><span class="p">...</span>
</span></span></code></pre></div><ul>
<li>优点
<ul>
<li>实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li>
</ul>
</li>
<li>缺点
<ul>
<li>不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并之心循环TSL指令，从而导致“忙等”</li>
</ul>
</li>
</ul>
<h3 id="总结-16">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-22%2022.47.31.png" alt=""></p>
<h2 id="234-互斥锁">2.3——4 互斥锁</h2>
<h3 id="什么是互斥锁">什么是互斥锁？</h3>
<ul>
<li>解决临界区最简单的工具</li>
<li>以工程在进入临界区时获得锁，在退出临界区时释放锁</li>
<li>函数acquire()获得锁，函数release()释放锁</li>
<li>每个互斥锁有一个布尔变量available表示锁是否可用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">acquire</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">available</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 忙等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">available</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 获得锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">release</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>   <span class="c1">// 释放锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现</li>
<li>互斥锁的主要缺点是忙等待；通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行</li>
<li>需要连续循环忙等的互斥锁，都可称为自旋锁(spin lock)，如TSL指令、swap指令、单标志法</li>
<li>特性
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间段，则等待时间代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于丹处理机系统，忙等的过程中不可能解锁</li>
</ul>
</li>
</ul>
<h2 id="23_5-信号量机制">2.3_5 信号量机制</h2>
<ul>
<li>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来<strong>对信号量进行操作</strong>，从而很方便的实现了进程互斥、进程同步</li>
<li>信号量其实就是一个<strong>变量</strong>(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量</li>
</ul>
<blockquote>
<p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题
一对原语：<strong>wait(S)原语和signal(S)原语</strong>，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数
wait, singal原语常简称为P, V操作，因此，做题的时候常把wait(S), signal(S)两个操作分别写为<strong>P(S), V(S)</strong></p>
</blockquote>
<h3 id="整型信号量">整型信号量</h3>
<ul>
<li>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">S</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 初始化整型信号量s，表示当前系统中可用的打印机资源数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait</span> <span class="p">(</span><span class="kt">int</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// wait原语，相当于“进入区”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="n">S</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// 如果资源数不够，就一直循环等待
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>        <span class="c1">// 如果资源数够，则占用一个资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// signal原语，相当于“退出区”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">S</span> <span class="o">=</span> <span class="n">S</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>          <span class="c1">// 使用完资源后，在退出去释放资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程P0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="c1">// 进入区，申请资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="err">使用打印机资源</span><span class="p">...</span> <span class="c1">// 临界区，访问资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span> <span class="c1">// 退出区，释放资源
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程P1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机资源</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 进程Pn
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机资源</span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span></code></pre></div><ul>
<li>与普通整数变量的区别：对信号量的操作只有三种，即 初始化、P操作、V操作</li>
<li>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</li>
<li>存在的问题
<ul>
<li>不满足“让权等待”原则，会发生“忙等”</li>
</ul>
</li>
</ul>
<h3 id="记录型信号量">记录型信号量</h3>
<ul>
<li>整型信号量的缺陷是存在“忙等”的问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/*记录型信号量的定义 */</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>   <span class="c1">// 剩余资源数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">process</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span> <span class="c1">// 等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">semaphore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/* 某进程需要使用资源时，通过wait原语申请 */</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">wait</span> <span class="p">(</span><span class="n">semaphore</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">S</span><span class="p">.</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">block</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把它挂到信号量S的等待队列(即阻塞队列)中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*进程使用完资源后，通过signal原语释放*/</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">signal</span> <span class="p">(</span><span class="n">semaphore</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">wakeup</span><span class="p">(</span><span class="n">S</span><span class="p">.</span><span class="n">L</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P0进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P1进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P2进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// P3进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">wait</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="err">使用打印机</span>
</span></span><span class="line"><span class="cl"><span class="nf">signal</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span></code></pre></div><h3 id="总结-17">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2016.09.34.png" alt=""></p>
<h2 id="23_6-用信号量实现进程互斥同步前驱关系">2.3_6 用信号量实现进程互斥、同步、前驱关系</h2>
<h3 id="实现进程互斥">实现进程互斥</h3>
<ol>
<li>分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)</li>
<li>设置互斥信号量mutex，初值为1
<ul>
<li>mutex表示“进入临界区的名额”</li>
</ul>
</li>
<li>在进入区(mutex)&ndash;申请资源</li>
<li>再退出区(mutex)&ndash;释放资源</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/*记录型信号量的定义*/</span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span> <span class="c1">// 剩余资源数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">struct</span> <span class="nc">process</span> <span class="o">*</span><span class="n">L</span><span class="p">;</span> <span class="c1">// 等待队列
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="n">semaphore</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cm">/*信号量机制实现互斥*/</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 初始化信号量 (简写)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">P1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// 使用临界资源前需要加锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="err">临界区代码段</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span> <span class="c1">// 使用临界资源后需要解锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">P2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">临界区代码段</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>注意
<ul>
<li>对不同的临界资源需要设置不同的互斥信号量</li>
<li>P, V操作必须成对出现，缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒</li>
</ul>
</li>
</ul>
<h3 id="实现进程同步">实现进程同步</h3>
<ul>
<li>进程同步：让各并发进程按要求有序地推进</li>
</ul>
<ol>
<li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作(或两句代码)</li>
<li>设置同步信号量S，初始为0</li>
<li>在“前操作”之后执行V(S)</li>
<li>在“后操作”之前执行P(S)</li>
</ol>
<ul>
<li>例：P2的代码4必须在P1的代码2之后进行操作</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/*信号量机制实现同步*/</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">S</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 初始化同步信号量，初始值为0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">P1</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">P2</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="err">代码</span><span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>理解
<ul>
<li>信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源</li>
</ul>
</li>
</ul>
<h3 id="实现进程的前驱关系">实现进程的前驱关系</h3>
<ul>
<li>每一对前驱关系都是一个进程同步问题</li>
</ul>
<ol>
<li>要为每一对前驱关系各设置一个同步信号量</li>
<li>在“前操作”之后对相应的同步信号量执行V操作</li>
<li>在“后操作”之前对相应的同步信号量执行P操作
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2016.41.54.png" alt=""></li>
</ol>
<h3 id="总结-18">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2016.44.28.png" alt=""></p>
<h2 id="23_7-生产者-消费者问题">2.3_7 生产者-消费者问题</h2>
<h3 id="问题描述">问题描述</h3>
<ul>
<li>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用</li>
<li>生产者、消费者共享一个初始为空、大小为n的缓冲区</li>
<li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待
<ul>
<li>缓冲区没满-&gt;生产者生产</li>
</ul>
</li>
<li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待
<ul>
<li>缓冲区没空-&gt;消费者消费</li>
</ul>
</li>
<li>缓冲区是临界资源，个进程必须互斥地访问
<ul>
<li>互斥关系</li>
</ul>
</li>
<li>PV操作题目分析步骤
<ul>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系</li>
<li>整理思路。根据各进程的操作流程确定P, V操作的大致顺序</li>
<li>设置信号量。并更具题目条件确定信号量初值(互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少)</li>
</ul>
</li>
</ul>
<h3 id="问题分析">问题分析</h3>
<ul>
<li>分析信号量的值
<ul>
<li>semaphore mutex = 1; // 互斥信号量，实现对缓冲区的互斥访问</li>
<li>semaphore empty = n; // 同步信号量，表示空闲缓冲区的数量</li>
<li>semaphore full = 0;  // 同步信号量，表示产品的数量，也即非缓冲区的数量</li>
</ul>
</li>
</ul>
<h3 id="如何实现">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 互斥信号量，实现对缓冲区的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">empty</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 同步信号量，表示空闲缓冲区的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 同步信号量，表示产品的数量，也即非缓冲区的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">producer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">生产一个产品</span>
</span></span><span class="line"><span class="cl">    <span class="nf">P</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// 消耗一个空闲缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">把产品放入缓冲区</span>
</span></span><span class="line"><span class="cl">    <span class="nf">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>  <span class="c1">// 增加一个产品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">consumer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">full</span><span class="p">);</span> <span class="c1">// 消耗一个产品(非空缓冲区)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">从缓冲区取走一个产品</span>
</span></span><span class="line"><span class="cl">    <span class="nf">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span> <span class="c1">// 增加一个空闲缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">使用产品</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>实现互斥是在同一进程中进行一对PV操作</li>
<li>实现两进程的同步关系，是在其中一个进程中执行P，另一个进程中执行V</li>
</ul>
<h3 id="思考">思考</h3>
<ul>
<li>能否改变相邻P, V操作的顺序
<ul>
<li>不能</li>
<li>生产者与消费者循环等待被对方唤醒，出现“死锁”</li>
<li>实现互斥的P操作一定要在实现同步的P操作之后</li>
<li>V操作不会导致进程阻塞，因此两个V操作顺序可以交换
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2017.02.51.png" alt=""></li>
</ul>
</li>
<li>能否把使用产品的代码放到PV操作之间？
<ul>
<li>会对系统的效能产生影响</li>
<li>应该使访问临界区的时间段尽可能短</li>
</ul>
</li>
</ul>
<h3 id="总结-19">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2017.05.19.png" alt=""></p>
<h2 id="23_8-多生产者-多消费者问题">2.3_8 多生产者-多消费者问题</h2>
<h3 id="问题描述-1">问题描述</h3>
<ul>
<li>桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程</li>
</ul>
<h3 id="问题分析-1">问题分析</h3>
<ul>
<li>
<p>关系分析</p>
<ul>
<li>互斥关系
<ul>
<li>对缓冲区(盘子)的访问要互斥的进行</li>
</ul>
</li>
<li>同步关系
<ol>
<li>父亲将苹果放入盘子后，女儿才能取苹果</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子</li>
<li>只有盘子为空时，父亲或母亲才能放入水果
<ul>
<li>“盘子为空”这个事件可以由儿子或女儿触发，事件发生之后才允许父亲或母亲放水果</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>整理思路</p>
<ul>
<li>根据各进程的操作流程确定P, V操作的大致顺序</li>
<li>互斥：在临界区前后分别PV</li>
<li>同步：前V后P</li>
</ul>
</li>
<li>
<p>设置信号量</p>
<ul>
<li>设置需要的信号量，并根据题目条件确定信号量初值</li>
<li>互斥信号量初值一般为1，同步信号量的初值要看对应资源的初始值是多少</li>
</ul>
</li>
</ul>
<h3 id="如何实现-1">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 实现互斥访问盘子(缓冲区)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">apple</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 盘子中有几个苹果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">orange</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 盘子中有几个橘子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">plate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 盘子中还可以放多少个水果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">dad</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">准备一个苹果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">把苹果放入盘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">apple</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">mom</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="err">准备一个橘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">把橘子放入盘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">orange</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">daughter</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">apple</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">从盘中取出苹果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">吃掉苹果</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">son</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">orange</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">从盘子中取出橘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">plate</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">吃掉橘子</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li><strong>注意</strong>：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</li>
</ul>
<blockquote>
<p>原因在于：本题中的缓冲区大小为1，在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</p>
</blockquote>
<h3 id="总结-20">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-23%2022.39.41.png" alt=""></p>
<h2 id="23_9-吸烟者问题">2.3_9 吸烟者问题</h2>
<h3 id="问题描述-2">问题描述</h3>
<ul>
<li>假设一个系统有三个抽烟者进程和一个供应者进程</li>
<li>每个抽烟者不停地卷烟并不停抽掉它，但是要卷起并抽掉一只烟，抽烟者需要有三种材料：烟草、纸和胶水</li>
<li>三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水</li>
<li>供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下哪种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)</li>
</ul>
<h3 id="问题分析-2">问题分析</h3>
<ul>
<li>关系分析
<ul>
<li>同步关系
<ul>
<li>桌子上有组合一-&gt;第一个抽烟者取走东西</li>
<li>桌子上有组合二-&gt;第二个抽烟者取走东西</li>
<li>桌子上有组合三-&gt;第三个抽烟者取走东西</li>
<li>发出完成信号-&gt;供应者将下一个组合放到桌子上</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设置信号量">设置信号量</h3>
<ul>
<li>可以不设置互斥信号量</li>
<li>同步信号量
<ul>
<li>offer1 = 0</li>
<li>offer2 = 0</li>
<li>offer3 = 0</li>
<li>finish = 0</li>
</ul>
</li>
</ul>
<h3 id="如何实现-2">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">offer1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 桌子上组合一的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">offer2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 桌子上组合二的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">offer3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 桌子上组合三的数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 抽烟是否完成
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">provider</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="err">将组合一放在桌上</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">offer1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="err">将组合二放桌上</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">offer2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">      <span class="err">将组合三放桌上</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">offer3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">P</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span> <span class="c1">// 保证刚刚开始的时候provider可以提供
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">smoker1</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">offer1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">从桌子上拿走组合一，卷烟，抽掉</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">smoker2</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">offer2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">从桌子上拿走组合二，卷烟，抽掉</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">smoker3</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">offer3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="err">从桌子上拿走组合三，卷烟，抽掉</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">finish</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>缓冲区大小为1，同一时刻，四个同步信号量中至多有一个的值为1</li>
</ul>
<h3 id="知识回顾与重要考点">知识回顾与重要考点</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-24%2009.04.23.png" alt=""></p>
<h2 id="23_10-读者-写者问题">2.3_10 读者-写者问题</h2>
<h3 id="问题描述-3">问题描述</h3>
<ul>
<li>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程(读进程和或写进程)同时访问共享数据时则可能导致数据不一致的错误
<ul>
<li>允许多个读者可以同时对文件执行读操作</li>
<li>只允许一个写者往文件中写信息</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出</li>
</ul>
</li>
</ul>
<h3 id="问题分析-3">问题分析</h3>
<ul>
<li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系
<ul>
<li>互斥关系：写进程-写进程、写进程-读进程</li>
</ul>
</li>
<li>整理思路。根据各进程的操作流程确定P, V操作的大致顺序</li>
<li>设置信号量。设置需要的信号量，并根据题目条件确定信号量的初值</li>
</ul>
<h3 id="如何实现-3">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">rw</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用于实现对共享文件的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 记录当前有几个读进程在访问文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>   <span class="c1">// 用于保证对count变量的互斥访问
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">semaphore</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 用于实现“写优先” (有排队功能，相对公平的先来先服务原则)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="n">writer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span> <span class="c1">// 写之前“加锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">写文件</span>
</span></span><span class="line"><span class="cl">    <span class="nf">V</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span> <span class="c1">// 写完了“解锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">reader</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 由第一个读进程负责读之前“加锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="n">P</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 访问文件的进程数+1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">读文件</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span><span class="o">--</span><span class="p">;</span> <span class="c1">// 访问文件的读进程数-1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">cout</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">V</span><span class="p">(</span><span class="n">rw</span><span class="p">);</span> <span class="c1">// 读完了“解锁”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>注意：对count的检查和赋值无法一气呵成</li>
<li>潜在的问题(不添加信号量w时)
<ul>
<li>只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”</li>
<li>因此，这种算法中，读进程是优先的</li>
</ul>
</li>
</ul>
<h3 id="核心思想">核心思想</h3>
<ul>
<li>设置计数器count用来记录当前正在访问共享文件的读进程数</li>
<li>可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理</li>
<li>另外，对count的检查和赋值不能一气呵成导致了一些错误，如果要实现“一气呵成”，应该用互斥信号量</li>
</ul>
<h2 id="23_11-哲学家进餐问题">2.3_11 哲学家进餐问题</h2>
<h3 id="问题描述-4">问题描述</h3>
<ul>
<li>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。</li>
<li>哲学家们倾注毕生的精力用于思考和进餐，哲学家思考时，并不影响他人。</li>
<li>只有当哲学家饥饿时，才试图拿起左、右两根筷子(一根一根地拿起)</li>
<li>如果筷子已在他人受伤，则需等待。</li>
<li>饥饿的哲学家只有同时拿起两根筷子才可以进餐，当进餐完毕后，放下筷子继续思考</li>
</ul>
<h3 id="问题分析-4">问题分析</h3>
<ul>
<li>关系分析
<ul>
<li>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间的筷子的访问是互斥关系</li>
</ul>
</li>
<li>整理思路
<ul>
<li>这个问题中只有互斥关系</li>
<li>每个哲学家进程需要同时持有两个临界资源才能开始吃饭</li>
<li>如果避免临界资源分配不当造成的死锁问题，是哲学家问题的精髓</li>
</ul>
</li>
<li>信号量设置
<ul>
<li>互斥信号量数组chopstick[5]={1, 1, 1, 1, 1}用于实现对5个筷子的互斥访问</li>
<li>并对哲学家按0~4编号，哲学家i左边的筷子为编号i，右边的筷子编号为(i + 1) % 5</li>
</ul>
</li>
</ul>
<h3 id="如何实现-4">如何实现</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">chopstick</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Pi</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// i号哲学家的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 拿左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 拿右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">吃饭</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 放左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 放右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>死锁</p>
<ul>
<li>当所有哲学家都拿起左筷子时，会造成死锁</li>
</ul>
</li>
<li>
<p>如何防止死锁？</p>
<ul>
<li>最多允许四个哲学家同时进餐(增加信号量count)</li>
<li>要求奇数号哲学家先拿左边的筷子，偶数号哲学家相反(避免了占有一支筷子之后等待另一支筷子的情形)</li>
<li>个哲学家拿筷子这件事必须互斥的执行</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">chopstick</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">semaphore</span> <span class="n">mutex</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Pi</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// i号哲学家的进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 拿左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 拿右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="err">吃饭</span><span class="p">...</span>
</span></span><span class="line"><span class="cl">    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 放左筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">V</span><span class="p">(</span><span class="n">chopstick</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">5</span><span class="p">]);</span> <span class="c1">// 放右筷子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 当一个哲学家两支筷子都拿起之后，其他哲学家才能开始拿筷子
</span></span></span><span class="line"><span class="cl"><span class="c1">// 即便有其他能拿到两支筷子，也不能执行
</span></span></span></code></pre></div><h3 id="知识回顾与重要考点-1">知识回顾与重要考点</h3>
<ul>
<li>哲学家进餐问题的关键在于解决进程死锁</li>
<li>这些进程之间只存在互斥关系，但每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患</li>
</ul>
<h2 id="23_12-管程">2.3_12 管程</h2>
<h3 id="为什么要引入管程">为什么要引入管程</h3>
<ul>
<li>信号量机制存在的问题
<ul>
<li>编写程序困难、易出错</li>
</ul>
</li>
<li>管程
<ul>
<li>一种高级的同步机制</li>
</ul>
</li>
</ul>
<h3 id="管程的定义和基本特征">管程的定义和基本特征</h3>
<ul>
<li>组成
<ul>
<li>局部于管程的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程有一个名字</li>
</ul>
</li>
<li>管程的基本特征
<ul>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong></li>
</ul>
</li>
</ul>
<h3 id="拓展1用管程解决生产者消费者问题">拓展1:用管程解决生产者消费者问题</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">monitor</span> <span class="n">ProducerConsumer</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 管程中设置条件变量和等待/唤醒操作，以解决同步问题
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">condition</span> <span class="n">full</span><span class="p">,</span> <span class="n">empty</span><span class="p">;</span> <span class="c1">// 条件变量用来实现同步(排队)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 缓冲区中的产品数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="c1">// 由编译器负责实现各进程互斥地进入管程中的过程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">void</span> <span class="nf">insert</span> <span class="p">(</span><span class="n">Item</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 把产品item放入缓冲区
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">N</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">wait</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">insert_item</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">signal</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">Item</span> <span class="nf">remove</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// 从缓冲区中取出一个产品
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">wait</span><span class="p">(</span><span class="n">empty</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">count</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">signal</span><span class="p">(</span><span class="n">full</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">remove_item</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">end</span> <span class="n">monitor</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 生产者进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">producer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">item</span> <span class="o">=</span> <span class="err">生产一个产品</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ProdecerConsumer</span><span class="p">.</span><span class="n">insert</span> <span class="p">(</span><span class="n">item</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 消费者进程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">consumer</span> <span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">item</span> <span class="o">=</span> <span class="n">ProdecerConsumer</span><span class="p">.</span><span class="n">remove</span> <span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="err">消费产品</span><span class="n">item</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>需要在管程中定义共享数据(如生产者消费者问题的缓冲区)</li>
<li>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数(如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>
<li>只有通过这些特定的“入口”才能访问共享数据</li>
<li>管程中有很多入口，但每次只能开放其中一个入口，并且只能让一个进程或线程进入</li>
</ol>
<ul>
<li>这种互斥特性是由编译器实现的</li>
</ul>
<ol start="5">
<li>可以在管程中设置条件变量及等待/唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权，也就是让出“入口”)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</li>
</ol>
<ul>
<li>程序员可以用某种特殊的语法定义一个管程，之后其他程序员就可以使用这个管程提供的特定“入口”很方便的使用实现进程同步/互斥了</li>
</ul>
<h3 id="拓展2java中类似于管程的机制">拓展2:Java中类似于管程的机制</h3>
<ul>
<li>Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">mointer</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="n">Item</span><span class="w"> </span><span class="n">buffer</span><span class="o">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Item</span><span class="o">[</span><span class="n">N</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// 每次只能有一个线程进入insert函数，如果多个线程同时调用insert函数，则后来者需要排队等待</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">insert</span><span class="w"> </span><span class="p">(</span><span class="n">Item</span><span class="w"> </span><span class="n">item</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">......</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="总结-21">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-24%2022.42.16.png" alt=""></p>
<h2 id="24_1-死锁的概念">2.4_1 死锁的概念</h2>
<h3 id="什么是死锁">什么是死锁</h3>
<ul>
<li>进程间相互等待的现象</li>
</ul>
<h3 id="进程死锁饥饿死循环的区别">进程死锁、饥饿、死循环的区别</h3>
<ul>
<li>死锁
<ul>
<li>各进程相互等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</li>
</ul>
</li>
<li>饥饿
<ul>
<li>由于长期得不到想要的资源，某进程无法向前推进的现象</li>
</ul>
</li>
<li>死循环
<ul>
<li>某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-24%2022.48.09.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="死锁产生的必要条件">死锁产生的必要条件</h3>
<ol>
<li>互斥条件
<ul>
<li>只有对必须互斥使用的资源的争抢才会导致死锁</li>
</ul>
</li>
<li>不剥夺条件
<ul>
<li>进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
</ul>
</li>
<li>请求和保持条件
<ul>
<li>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
</ul>
</li>
<li>循环等待条件
<ul>
<li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ul>
</li>
</ol>
<ul>
<li>注意
<ul>
<li>发生死锁时一定有循环等待，但是发生循环等待时未必死锁(循环等待是四所发生的必要不充分条件)</li>
<li>如果同类资源数大于1，则即使有循环等待，也未必发生死锁</li>
<li>但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了</li>
</ul>
</li>
</ul>
<h3 id="什么时候会发生死锁">什么时候会发生死锁</h3>
<ul>
<li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源(CPU)的竞争是不会引发死锁的</li>
<li>进程推进顺序非法。请求和释放资源的顺序不当，同样会导致死锁。例如，并发执行的进程P1, P2分别申请并占有了资源R1, R2，之后进程P1又紧接着申请资源R2，而进程R2又申请资源R1，两者都会因为申请的资源被对方占有而阻塞，从而发生死锁</li>
<li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁(可以把互斥信号量、同步信号量也看作是一种抽象的系统资源)</li>
<li>总之，对不可剥夺的资源分配不合理，就有可能导致死锁</li>
</ul>
<h3 id="死锁的处理策略">死锁的处理策略</h3>
<ol>
<li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li>
<li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li>
<li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li>
</ol>
<h3 id="总结-22">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2007.56.34.png" alt=""></p>
<h2 id="24_2-死锁的处理策略预防死锁">2.4_2 死锁的处理策略——预防死锁</h2>
<h3 id="破坏互斥条件只有对必须互斥使用的资源的争抢才会导致死锁">破坏互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</h3>
<ul>
<li>把只能互斥使用的资源改造为允许共享使用，比如SPOOLing技术，可将打印机改造为共享设备
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2007.57.03.png" alt=""></li>
<li>缺点
<ul>
<li>并不是所有资源都可以改造成共享使用的资源</li>
<li>为了系统安全，很多地方还必须保护这种互斥性</li>
<li>因此，很多时候无法破坏互斥条件</li>
</ul>
</li>
</ul>
<h3 id="破坏不剥夺条件">破坏不剥夺条件</h3>
<ul>
<li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li>
<li>破坏不剥夺条件
<ul>
<li>方案一：当进程请求新的资源得不到满足时，它必须立即释放所保持的资源</li>
<li>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。一般需要考虑各进程的优先级(比如，剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</li>
</ul>
</li>
<li>缺点
<ul>
<li>实现起来比较复杂</li>
<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复的资源，如CPU</li>
<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li>
<li>若采用方案一，意味着只要暂时的不的某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li>
</ul>
</li>
</ul>
<h3 id="破坏请求和保持条件">破坏请求和保持条件</h3>
<ul>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而新资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>
<li>可采用<strong>静态分配方法</strong>
<ul>
<li>进程在运行前一次申请完它需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了</li>
</ul>
</li>
<li>缺点
<ul>
<li>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低</li>
<li>另外，该策略也有可能导致某些进程饥饿</li>
</ul>
</li>
</ul>
<h3 id="破坏循环等待条件">破坏循环等待条件</h3>
<ul>
<li>循环等待条件
<ul>
<li>存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>
</ul>
</li>
<li>顺序资源分配法
<ul>
<li>给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完</li>
</ul>
</li>
<li>原理分析
<ul>
<li>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源</li>
<li>按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象</li>
</ul>
</li>
<li>缺点
<ul>
<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>
<li>进程实际使用的资源的顺序可能和编号递增顺序不一致，会导致资源浪费</li>
<li>必须按规定次序申请资源，用户变成麻烦</li>
</ul>
</li>
</ul>
<h3 id="总结-23">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.37.45.png" alt=""></p>
<h2 id="24_3-死锁的处理策略避免死锁">2.4_3 死锁的处理策略——避免死锁</h2>
<h3 id="什么是安全序列">什么是安全序列</h3>
<ul>
<li>安全序列：如果系统按照这种顺序分配资源，则每个进程都能顺利完成。</li>
<li>安全状态：只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个</li>
<li>不安全状态：如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态，这就意味着之后可能所有进程都无法顺利的执行下去</li>
<li>安全状态与死锁之间的关系
<ul>
<li>如果系统处于安全状态，就一定不会发生死锁</li>
<li>如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</li>
</ul>
</li>
<li>“银行家算法”的核心思想
<ul>
<li>可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</li>
</ul>
</li>
</ul>
<h3 id="银行家算法">银行家算法</h3>
<ul>
<li>用于避免死锁
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.53.46.png" alt=""></li>
</ul>
<h3 id="知识回顾与重要考点-2">知识回顾与重要考点</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.55.43.png" alt=""></p>
<h2 id="24_4-死锁的处理策略检测和解除">2.4_4 死锁的处理策略——检测和解除</h2>
<h3 id="死锁检测算法">死锁检测算法</h3>
<ul>
<li>用某种数据结构来保存资源的请求和分配信息
<img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2010.58.10.png" alt=""></li>
<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li>
<li>算法思想
<ul>
<li>如果能消除所有边，就称这个图是可完全简化的，此时一定没有发生死锁</li>
<li>如果不能消除所有边，那么此时就是发生了死锁</li>
<li>最终还连着边的那些进程就是处于死锁状态的进程</li>
</ul>
</li>
<li>检测死锁的算法
<ul>
<li>在资源分配图中，找出既不阻塞有不是孤点的进程Pi，消去它所有的请求边和分配边</li>
<li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，经过一系列化简后，若能消去途中的所有边，则称该图是可完全化简的</li>
<li>死锁定理：如果某时刻系统的资源分配图是不可完全化简的，那么此时系统死锁</li>
</ul>
</li>
</ul>
<h3 id="死锁解除算法">死锁解除算法</h3>
<ul>
<li>化简后还连着边的进程就是死锁进程</li>
<li>一旦检测出死锁的发生，就应该立即解除死锁</li>
<li>解除死锁的主要方法
<ol>
<li>资源剥夺法
<ul>
<li>刮起某些死锁进程，并抢占它的资源，分配给其他死锁进程</li>
<li>但是应防止被挂起的进程长时间得不到资源而结</li>
</ul>
</li>
<li>撤销进程法
<ul>
<li>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源</li>
<li>优点
<ul>
<li>实现简单</li>
</ul>
</li>
<li>缺点
<ul>
<li>付出的代价可能会很大</li>
</ul>
</li>
</ul>
</li>
<li>进程回退法
<ul>
<li>让一个或多个死锁进程回退到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点</li>
</ul>
</li>
</ol>
</li>
<li>如何决定“对谁动手”
<ol>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ol>
</li>
</ul>
<h3 id="总结-24">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-10-25%2011.12.07.png" alt=""></p>
<h1 id="第三章-内存管理">第三章 内存管理</h1>
<h2 id="31_1-内存的基础知识">3.1_1 内存的基础知识</h2>
<h3 id="什么是内存有何作用">什么是内存，有何作用</h3>
<ul>
<li>内存可存放数据</li>
<li>程序执行前需要先放到内存中才能被CPU处理
<ul>
<li>缓和CPU与硬盘之间的速度矛盾</li>
</ul>
</li>
<li>内存地址从0开始，每个地址对应一个存储单元</li>
<li>存储单元
<ul>
<li>按字节编址——每个存储单元大小为1字节，即1B，即8个二进制位</li>
<li>按字编址——每个存储单元的大小为1个字，每个字的大小为16个二进制位</li>
</ul>
</li>
</ul>
<h3 id="进程运行的基本原理">进程运行的基本原理</h3>
<ul>
<li>装入的三种方式
<ul>
<li><strong>绝对装入</strong>
<ul>
<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码，装入程序按照从装入模块中的地址，将程序和数据装入内存</li>
<li>只适用于单道程序环境</li>
<li>灵活性很低</li>
</ul>
</li>
<li><strong>静态重定位</strong>
<ul>
<li>可重定位装入</li>
<li>在程序装入内存时进行地址转换</li>
<li>在一个作业装入内存时，必须分配其要求的全部内存空间</li>
<li>在程序运行期间不可移动</li>
</ul>
</li>
<li><strong>动态运行时装入(动态重定位)</strong>
<ul>
<li>需要重定位寄存器的支持</li>
<li>程序真正要执行时，进行地址转换</li>
<li>允许程序在内存中发生移动</li>
<li>可以将程序分配到不连续的存储区</li>
<li>根据需要动态申请分配内存</li>
<li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-25">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-01%2010.45.32.png" alt=""></p>
<ul>
<li>链接是为了形成完整的逻辑地址</li>
<li>装入是为了形成物理地址</li>
</ul>
<blockquote>
<p>动态链接在使用库的时候特别有用
存根</p>
</blockquote>
<h2 id="31_2-内存管理的概念">3.1_2 内存管理的概念</h2>
<blockquote>
<p>地址联编 Address building (三个阶段)
阶段一：Compile time(用的很少)
阶段二：Load time
阶段三：Execution time(动态联编)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2010.14.05.png" alt=""></p>
</blockquote>
<blockquote>
<p>MMU 内存管理单元</p>
</blockquote>
<h3 id="内存空间的分配与回收">内存空间的分配与回收</h3>
<h3 id="对内存空间进行扩充">对内存空间进行扩充</h3>
<h3 id="地址转换">地址转换</h3>
<ul>
<li>负责逻辑地址与物理地址的转换</li>
<li>三种装入方式
<ul>
<li>绝对装入
<ul>
<li>单道程序阶段，此时还没产生操作系统</li>
</ul>
</li>
<li>可重定位装入
<ul>
<li>用于早期的多道批处理操作系统</li>
</ul>
</li>
<li>动态运行时装入
<ul>
<li>现代操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内存保护">内存保护</h3>
<blockquote>
<p>ROM 只读存储器
内存中：区分用户态和内核态(用户进程不能处理操作系统)
只能访问自己规定的内存(越界保护)</p>
</blockquote>
<ul>
<li>方法一 上、下限寄存器</li>
<li>方法二
<ul>
<li>重定位寄存器(基质寄存器)</li>
<li>界地址寄存器(限长寄存器)</li>
</ul>
</li>
</ul>
<h3 id="总结-26">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-01%2011.09.27.png" alt=""></p>
<h2 id="31_3-覆盖与交换">3.1_3 覆盖与交换</h2>
<h3 id="覆盖技术">覆盖技术</h3>
<ul>
<li>覆盖技术用来解决<strong>程序大小超过物理内存总和</strong>的问题</li>
<li>思想
<ul>
<li>将程序分为多个段(多个模块)
<ul>
<li>常用的段常驻内存</li>
<li>不常用的段在需要时调入内存</li>
</ul>
</li>
<li>内存中分为一个“固定区”和若干个“覆盖区”
<ul>
<li>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</li>
<li>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</li>
</ul>
</li>
</ul>
</li>
<li>示例
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-02%2008.44.30.png" alt=""></li>
<li>必须由程序员声明覆盖结构，操作系统完成自动覆盖</li>
<li>缺点
<ul>
<li>对用户不透明，增加了用户负担</li>
</ul>
</li>
<li>覆盖技术只用于早期的操作系统中，现在已成为历史</li>
</ul>
<h3 id="交换技术">交换技术</h3>
<blockquote>
<p>windows下</p>
</blockquote>
<ul>
<li>设计思想
<ul>
<li>内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</li>
<li>进程的PCB会常驻内存，不会被换出外存(保存进程状态信息)</li>
</ul>
</li>
<li>中级调度（内存调度）
<ul>
<li>决定将哪个处于挂起状态的进程重新调入内存</li>
</ul>
</li>
<li>挂起状态
<ul>
<li>就绪挂起</li>
<li>阻塞挂起
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-02%2008.50.18.png" alt=""></li>
</ul>
</li>
<li>被换出的进程数据存储在磁盘的什么位置？
<ul>
<li>对换区</li>
<li><strong>对换区</strong>的I/O速度比文件区的更快，采用<strong>连续分配方式</strong></li>
<li><strong>文件区</strong>主要追求空间的利用率，对文件区空间的管理采用<strong>离散分配方式</strong></li>
</ul>
</li>
<li>什么时候应该进行交换？
<ul>
<li>许多进程运行且内存吃紧时</li>
<li>例如：在许多进程运行时经常发生缺页，说明内存紧张；如果缺页率明显下降，就可以暂停换出</li>
</ul>
</li>
<li>应该换出那些进程？
<ul>
<li>可优先换出阻塞进程</li>
<li>可换出优先级低的进程
<ul>
<li>为防止饥饿，有些操作系统还会考虑进程在内存中的驻留时间</li>
</ul>
</li>
</ul>
</li>
<li>注意：PCB会常驻内存，不会被换出外存
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-02%2008.58.22.png" alt=""></li>
</ul>
<h2 id="31_4-连续分配管理方式">3.1_4 连续分配管理方式</h2>
<h3 id="单一连续分配">单一连续分配</h3>
<ul>
<li>内存被分为系统区和用户区
<ul>
<li>系统区通常位于内存的低地址部分，用于存放操作系统的相关数据</li>
<li>用户区用于存放用户进程相关数据</li>
</ul>
</li>
<li>内存中只能有一道用户程序，用户程序独占整个用户控件</li>
<li>优点
<ul>
<li>实现简单</li>
<li><strong>无外部碎片</strong></li>
<li>可以采用覆盖技术扩充内存</li>
<li>不一定需要采取内存保护(eg: 早期的PC操作系统MS-DOS)</li>
</ul>
</li>
<li>缺点
<ul>
<li>只适用于单用户、单任务的操作系统中</li>
<li><strong>有内部碎片</strong></li>
<li>存储器利用率低</li>
</ul>
</li>
</ul>
<blockquote>
<p>越界原因</p>
<ol>
<li>程序写错了</li>
<li>系统出错</li>
<li>编译器生成了错误代码</li>
</ol>
</blockquote>
<h3 id="固定分区分配">固定分区分配</h3>
<ul>
<li>将整个用户控件划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式</li>
<li>分类
<ul>
<li>分区大小相等
<ul>
<li>缺乏灵活性</li>
<li>但是很适合用于一台计算机控制多个相同对象的场合</li>
</ul>
</li>
<li>分区大小不等
<ul>
<li>增加了灵活性，可以满足不同大小的进程需求</li>
<li>根据常在系统中运行的作业大小情况进行划分</li>
</ul>
</li>
</ul>
</li>
<li>分区说明表
<ul>
<li>分区号</li>
<li>分区大小</li>
<li>起始地址</li>
<li>状态(是否已分配)</li>
</ul>
</li>
<li>优点
<ul>
<li>实现简单</li>
<li><strong>无外部碎片</strong></li>
</ul>
</li>
<li>缺点
<ul>
<li>当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能</li>
<li><strong>会产生内部碎片</strong>，内存利用率低</li>
</ul>
</li>
</ul>
<h3 id="动态分区分配">动态分区分配</h3>
<ul>
<li><strong>动态分区分配</strong>又称为<strong>可变分区分配</strong></li>
<li>不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要</li>
<li>系统分区的大小和数目是可变的</li>
<li>用什么数据结构？
<ul>
<li>空闲分区表
<ul>
<li>每个空闲分区对应一个表项</li>
<li>分区号、分区大小、分区起始地址</li>
</ul>
</li>
<li>空闲分区链
<ul>
<li>每个分区的起始部分和末尾部分分别设置前向指针和后向指针</li>
<li>起始部分处还可记录分区大小等信息</li>
</ul>
</li>
</ul>
</li>
<li>当有很多个空闲分区都能满足需求时，应该选择哪个分区？
<ul>
<li>动态分区分配算法</li>
</ul>
</li>
<li>如何进行分区的分配与回收
<ul>
<li>分配
<ul>
<li>在空闲分区表中修改分区大小与起始地址</li>
<li>在空闲分区表中删除分配完的表项</li>
</ul>
</li>
<li>回收
<ul>
<li>回收区后面有一个相邻的空闲分区：更新空闲分区表中的分区大小和起始地址-&gt;如果更新后两分区相邻，合二为一</li>
<li>回收区的前面有一个相邻的空闲分区：合二为一</li>
<li>回收区的前、后各有一个相邻的空闲分区：相邻分区合并</li>
<li>回收区前、后都没有相邻的空闲分区：新增一个表项(具体排列方式需要依据动态分区分配算法来确定)</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>内部碎片(Internal Fragmentation)</strong>：分配给某进程的内存区域中，如果有些部分没有用上
<strong>外部碎片(External Fragmentation)</strong>，指内存中的某些空闲分区由于太小而难以利用</p>
</blockquote>
<ul>
<li>动态分区分配<strong>没有内部碎片</strong>，但是<strong>有外部碎片</strong></li>
<li>如果内存中空闲空间的总和本来可以满足进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求
<ul>
<li>可以通过紧凑(拼凑)技术来解决外部碎片
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-02%2009.31.40.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="31_5-动态分区分配算法">3.1_5 动态分区分配算法</h2>
<ul>
<li>解决的问题：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</li>
</ul>
<h3 id="首次适应算法-first-fit">首次适应算法 First Fit</h3>
<ul>
<li>算法思想
<ul>
<li>每次从低地址开始查找，找到第一个能满足大小的空闲分区</li>
</ul>
</li>
<li>如何实现
<ul>
<li>空闲分区以地址递增的次序排列</li>
<li>每次分配内存时顺序查找空闲分区链/空闲分区表，找到能满足要求的第一个空闲分区</li>
</ul>
</li>
</ul>
<h3 id="最佳适应算法-best-fit">最佳适应算法 Best Fit</h3>
<ul>
<li>算法思想
<ul>
<li>优先使用更小的空闲区</li>
</ul>
</li>
<li>如何实现
<ul>
<li>空闲分区按容量递增次序链接</li>
<li>每次分配内存时顺序查找空闲分区链/空闲分区表，找到大小能满足要求的第一个空闲分区</li>
<li>每次分配后，更新，重新排序</li>
</ul>
</li>
<li>缺点
<ul>
<li>会留下越来越多的、很小的、难以利用的内存块</li>
<li>会产生很多外部碎片</li>
</ul>
</li>
</ul>
<h3 id="最坏适应算法-worst-fit-最大适应算法">最坏适应算法 Worst Fit (最大适应算法)</h3>
<ul>
<li>算法思想
<ul>
<li>优先使用最大的空闲区</li>
</ul>
</li>
<li>如何实现
<ul>
<li>空闲分区按容量递减次序链接</li>
<li>每次分配内存时顺序查找分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区</li>
</ul>
</li>
<li>缺点
<ul>
<li>会导致较大的连续空间被迅速用完</li>
<li>如果之后有“大进程”到达，就没有内存分区可用了</li>
</ul>
</li>
</ul>
<h3 id="临近适应算法-next-fit">临近适应算法 Next Fit</h3>
<ul>
<li>算法思想
<ul>
<li>每次都从上次查找结束的位置开始检索</li>
<li>为了解决首次适应算法导致低地址部分出现很多小的空闲分区的问题</li>
</ul>
</li>
<li>如何实现
<ul>
<li>空闲分区以地址递增的顺序排列(可排成一个循环链表)</li>
<li>每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区</li>
</ul>
</li>
<li>优点
<ul>
<li>无需重新排列，开销小</li>
</ul>
</li>
<li>首次适应算法vs临近适应算法
<ul>
<li>首次适应算法更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点)</li>
<li>临近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后大致五大分区可用(最大适应算法的缺点)</li>
</ul>
</li>
<li><strong>首次适应算法的效果最好</strong></li>
</ul>
<blockquote>
<p>分区分配存储管理地址保护：界地址寄存器</p>
</blockquote>
<h3 id="总结-27">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-03%2014.31.48.png" alt=""></p>
<h2 id="31_6-基本分页存储管理的概念">3.1_6 基本分页存储管理的概念</h2>
<h3 id="什么是分页存储">什么是分页存储</h3>
<ul>
<li>将内存空间分为一个个大小相等的分区，每个分区就是一个**“页框”(页框=页帧=内存块=物理页面)**
<ul>
<li>每个页框有一个编号，即“页框号”，页框号从0开始</li>
</ul>
</li>
<li>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个**“页”或“页面”**
<ul>
<li>每个页面也有一个编号，即“页号”，页号也是从0开始</li>
</ul>
</li>
<li>进程的页面与内存的页框有一一对应的关系
<ul>
<li>各个页面不必连续存放，可以放到不相邻的各个页框中</li>
<li>每页逻辑上连续，物理上不连续</li>
</ul>
</li>
</ul>
<blockquote>
<p>物理块大
优点：I/O次数少
缺点：浪费空间大
让物理块变大-&gt;用空间换时间</p>
</blockquote>
<h3 id="页表">页表</h3>
<ul>
<li>页表通常存在PCB中</li>
<li>一个进程对应一张页表</li>
<li>进程的每个页面对应一个页表项</li>
<li>每个页表项由“页号”和“块号/页框号”组成</li>
<li>页表记录进程页面和实际存放的内存块之间的映射关系</li>
<li>页表存放于内存中，读取一个数据需要<strong>两次访存</strong></li>
<li><strong>有效位和无效位</strong>
<ul>
<li>内存中必须放一个二进制位，因此需要用标志位标记它是否是帧号</li>
</ul>
</li>
</ul>
<h3 id="页表结构">页表结构</h3>
<ul>
<li>层级页表(Hierarchical Paging)</li>
<li>哈希页表(Hashed Page Tables)
<ul>
<li>执行速度快</li>
<li>遇到冲突比较麻烦</li>
</ul>
</li>
<li>逆页表(Inverted Page Tables)
<ul>
<li>实体由保存在内存中的虚拟地址组成，保存拥有这个页的进程</li>
<li>优点：节省空间</li>
<li>缺点：查找时间长</li>
</ul>
</li>
</ul>
<h3 id="每个页表项占多少字节">每个页表项占多少字节</h3>
<ul>
<li>内存块数量-&gt;页表项中块号至少占多少字节
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-03%2014.44.07.png" alt=""></li>
<li>页号不需要占存储空间
<ul>
<li>连续存储</li>
<li>页号可以是隐含的</li>
</ul>
</li>
</ul>
<h3 id="如何实现地址的转换">如何实现地址的转换</h3>
<ul>
<li>特点
<ul>
<li>虽然各进程的各个页面是离散存放的，但页面内部是连续存放的</li>
</ul>
</li>
<li>如果要访问逻辑地址A
<ul>
<li>确定逻辑地址A对应的“页号”P</li>
<li>找到P号页面在内存中的起始地址(需要查页表)</li>
<li>确定逻辑地址A的“页内偏移量”W</li>
</ul>
</li>
<li>逻辑地址A对应的物理地址 = P号页面在内存中的起始地址+页内偏移量W
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-03%2014.50.48.png" alt=""></li>
<li>子问题：如何确定一个逻辑地址对应的页号、页内偏移量？
<ul>
<li>页号 = 逻辑地址/页面长度(取除法的整数部分)</li>
<li>页内偏移量 = 逻辑地址 % 页面长度(取除法的余数部分)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-03%2022.26.43.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-03%2022.29.19.png" alt=""></li>
</ul>
</li>
<li>总结：页面大小刚好是2的整数幂有什么好处？
<ul>
<li>逻辑地址的拆分更为迅速</li>
<li>物理地址的计算更加迅速</li>
</ul>
</li>
</ul>
<h3 id="逻辑地址结构">逻辑地址结构</h3>
<ul>
<li>页面大小&lt;&ndash;&gt;页内偏移量位数 -&gt; 逻辑地址结构</li>
<li>结构：页号P + 页内偏移量W</li>
</ul>
<h3 id="总结-28">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-03%2022.34.42.png" alt=""></p>
<h2 id="31_7-基本地址变换机构">3.1_7 基本地址变换机构</h2>
<ul>
<li>基本地址变换机构：用于实现逻辑地址到物理地址转换的一组硬件机构</li>
<li>页表寄存器
<ul>
<li>页表在内存中的起始地址F</li>
<li>页表长度M</li>
</ul>
</li>
<li>进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</li>
<li>根据逻辑地址计算物理地址
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2020.57.15.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.00.39.png" alt=""></li>
<li>在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。
<ul>
<li>页式管理中地址是一维的(只需要给出逻辑地址这一个值)</li>
<li>只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</li>
</ul>
</li>
<li>注意检查<strong>页号是否越界</strong>
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.09.37.png" alt=""></li>
</ul>
<h3 id="总结-29">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.12.03.png" alt=""></p>
<h2 id="31_8-具有快表的地址变换机构">3.1_8 具有快表的地址变换机构</h2>
<h3 id="什么是快表">什么是快表</h3>
<ul>
<li>快表，又称联想寄存器(TLB)，是一种访问速度比内存快很多的<strong>高速缓存(Cache)</strong>(TLB不是内存！)，用来存放最近访问的页表项的副本，可以加速地址变换的速度，与此对应，内存(RAM)中的页表常称为<strong>慢表</strong></li>
</ul>
<h3 id="引入快表后地址的变换过程">引入快表后，地址的变换过程</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.21.36.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.26.14.png" alt=""></p>
<blockquote>
<p>EAT (Effective Access Time)
(1 + ε) * α + (2 + ε) * (1 - α)</p>
</blockquote>
<ul>
<li>快表与慢表同时查找
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.27.26.png" alt=""></li>
</ul>
<h3 id="局部性原理">局部性原理</h3>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
<h3 id="总结-30">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-04%2021.30.09.png" alt=""></p>
<h2 id="31_9-两级页表">3.1_9 两级页表</h2>
<h3 id="单级页表存在的问题">单级页表存在的问题</h3>
<ul>
<li>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</li>
<li>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</li>
</ul>
<h3 id="两级页表解决问题一">两级页表(解决问题一)</h3>
<ul>
<li>为离散分配的页表再建立一张页表，成为页目录表，或称<strong>外层页表</strong>，或称<strong>顶层页表</strong></li>
<li>小页表成为二级页表
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2008.34.00.png" alt=""></li>
<li>例
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2008.36.07.png" alt=""></li>
</ul>
<h3 id="虚拟存储技术">虚拟存储技术</h3>
<ul>
<li>可以在需要访问页面时才把页面调入内存(虚拟存储技术)</li>
<li>可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li>
<li>若想发给你问的页面不在内存中，则产生缺页中断(内中断)，然后将目标页面从外存调入内存</li>
</ul>
<h3 id="细节">细节</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2008.43.54.png" alt=""></p>
<h3 id="缺点">缺点</h3>
<ul>
<li><strong>访存次数增多</strong>
<ul>
<li>n级页表访存次数：n+1次</li>
</ul>
</li>
</ul>
<h3 id="总结-31">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2008.45.46.png" alt=""></p>
<blockquote>
<p>页表的内存保护
标识位：标识是否有效</p>
</blockquote>
<h2 id="31_10-基本分段存储管理方式">3.1_10 基本分段存储管理方式</h2>
<h3 id="分段">分段</h3>
<ul>
<li>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址</li>
<li>内存分配规则
<ul>
<li>以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2008.57.10.png" alt=""></li>
</ul>
</li>
<li>段号的位数决定了每个进程最多可以分几个段</li>
<li>段内地址位数决定了每个段的最大长度是多少</li>
</ul>
<h3 id="段表">段表</h3>
<ol>
<li>每个段对应一个段表项，其中记录了该段在内存中的起始位置(又称“基址”)和段的长度
<ul>
<li>段号+段长+基质</li>
</ul>
</li>
<li>各个段表项的长度是相同的
<ul>
<li>段号可以是隐含的，不占存储空间</li>
</ul>
</li>
</ol>
<h3 id="地址变换">地址变换</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2009.09.28.png" alt=""></p>
<ul>
<li>需要检查段<strong>是否越界</strong></li>
</ul>
<h3 id="分段分页管理的对比">分段、分页管理的对比</h3>
<ul>
<li>页是信息的物理单位
<ul>
<li>分页的主要目的是为了实现离散分配，提高内存利用率</li>
<li>分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的</li>
</ul>
</li>
<li>段是信息的逻辑单位
<ul>
<li>分段的主要目的是更好地满足用户需求</li>
<li>一个段通常包含着一组属于一个逻辑模块的信息</li>
<li>分段对用户是可见的，用户编程时需要显式的给出段名</li>
</ul>
</li>
<li>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</li>
<li>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</li>
<li>分段的用户进程地址空间时二位的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</li>
<li>分段比分页更容易实现信息的共享和保护
<ul>
<li>共享：只需让各进程的段表项指向同一个段即可实现共享</li>
</ul>
</li>
</ul>
<blockquote>
<p>纯代码/可重入代码，执行过程中代码本身不能改变，可以共享，不属于临界资源(可共享代码、只读代码)
可修改的代码是不能共享的
私有代码和数据</p>
</blockquote>
<ul>
<li>访问一个逻辑地址需要几次访问？
<ul>
<li>分页(单级页表)：两次访存</li>
<li>分段存储：两次访存
<ul>
<li>第一次访存：查内存中的段表</li>
<li>第二次访存：访问目标内存单元</li>
</ul>
</li>
<li>分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-05%2009.23.02.png" alt=""></li>
</ul>
</li>
</ul>
<h2 id="31_11-段页式管理方式">3.1_11 段页式管理方式</h2>
<ul>
<li>x86</li>
</ul>
<h3 id="分页分段管理方式中最大的优缺点">分页、分段管理方式中最大的优缺点</h3>
<table>
  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center">优点</th>
          <th style="text-align: center">缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center">分页管理</td>
          <td style="text-align: center">内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td>
          <td style="text-align: center">不方便按照逻辑模块实现信息的共享和保护</td>
      </tr>
      <tr>
          <td style="text-align: center">分段管理</td>
          <td style="text-align: center">很方便按照逻辑模块实现信息的共享和保护</td>
          <td style="text-align: center">如果段长过大，为其分配很大的连续空间会很不方便；会产生外部碎片</td>
      </tr>
  </tbody>
</table>
<ul>
<li>分段管理中产生的外部碎片也可以用“紧凑”来解决，只是需要付出较大的时间代价</li>
</ul>
<h3 id="分段分页的结合段页式管理方式">分段+分页的结合——段页式管理方式</h3>
<ul>
<li>将进程按逻辑模块分段，再将各段分页</li>
<li>再将内存空间氛围大小相同的内存块/页框/页帧/物理块</li>
<li>进程前将个页面分别装入各内存块中
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-06%2022.29.39.png" alt=""></li>
<li>逻辑地址结构
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-06%2022.31.13.png" alt="">
<ul>
<li>二维的：段号+段内地址(-&gt;页号+页内偏移量)</li>
</ul>
</li>
</ul>
<h3 id="段表页表">段表、页表</h3>
<ul>
<li>一个进程对应一个段表，一个段表项对应一个页表-&gt;一个进程对应多个页表
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-06%2022.34.53.png" alt=""></li>
</ul>
<h3 id="如何实现地址变换">如何实现地址变换</h3>
<ul>
<li>三次访存
<ul>
<li>段表</li>
<li>页表</li>
<li>内存单元</li>
</ul>
</li>
<li>可引入快表机构
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-06%2022.38.49.png" alt=""></li>
</ul>
<h3 id="总结-32">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-06%2022.42.54.png" alt=""></p>
<h2 id="32_1-虚拟内存的基本概念">3.2_1 虚拟内存的基本概念</h2>
<ul>
<li>实现内存扩充的一种技术</li>
<li>比交换技术和覆盖技术更先进一些</li>
</ul>
<h3 id="传统存储管理方式的特征缺点">传统存储管理方式的特征、缺点</h3>
<ul>
<li>连续分配</li>
<li>非连续分配</li>
<li>特征
<ul>
<li>一次性：作业必须一次性全部装入内存后才能开始运行
<ul>
<li>作业很大时，不能全部装入内存，导致大作业无法运行</li>
<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li>
</ul>
</li>
<li>驻留性
<ul>
<li>一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束</li>
<li>事实上，在一个时间段内，只需要访问作业的一小部分数据即可郑航运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="局部性原理-1">局部性原理</h3>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
<h3 id="虚拟内存的定义和特征">虚拟内存的定义和特征</h3>
<ul>
<li>
<p>定义</p>
<ul>
<li>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行</li>
<li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</li>
<li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</li>
<li>Page is needed -&gt; reference to it
<ul>
<li>invalid reference -&gt; abort</li>
<li>not-in-memory -&gt; bring to memory</li>
</ul>
</li>
<li>valid-invalid bit</li>
<li>Page fault(缺页中断)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2010.06.10.png" alt=""></li>
<li>EAT
<ul>
<li>(1 - ρ) * memory access + p(page fault overhead + [swap page out] + swap page in + restart overhead)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>特征</p>
<ul>
<li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存</li>
<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li>
<li>虚拟性：从逻辑上扩充了内存的容量，是用户看到的内存容量，远大于实际的容量</li>
</ul>
</li>
</ul>
<h3 id="如何实现虚拟内存技术">如何实现虚拟内存技术</h3>
<ul>
<li>允许一个作业多次调入内存-&gt;离散分配的内存管理方式</li>
<li>传统的非连续分配存储管理(对比)
<ul>
<li>基本分页存储管理</li>
<li>基本分段存储管理</li>
<li>基本段页式存储管理</li>
</ul>
</li>
<li>虚拟内存的实现
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ul>
</li>
<li>传统的非连续分配存储管理vs虚拟内存
<ul>
<li>主要区别
<ul>
<li>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序(操作系统要请求调页/调段功能)</li>
<li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存(操作系统要提供页面置换/段置换功能)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-33">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2010.51.39.png" alt=""></p>
<h2 id="32_2-请求分页管理方式-demand-paging">3.2_2 请求分页管理方式 Demand Paging</h2>
<ul>
<li>若程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序
<ul>
<li>操作系统要提供请求调页功能，将缺失页面从外存调入内存</li>
<li>Demand Paging
<ul>
<li>Less I/O needed</li>
<li>Less memory needed</li>
<li>Faster response</li>
<li>More users</li>
</ul>
</li>
</ul>
</li>
<li>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存 Page Replacement
<ul>
<li>操作系统要提供页面置换功能，将暂时用不到的页面换出外存</li>
</ul>
</li>
<li>Page is needed -&gt; reference to it
<ul>
<li>invalid reference -&gt; abort</li>
<li>not-in-memory -&gt; bring to memory</li>
</ul>
</li>
<li>valid-invalid bit</li>
<li>Page fault(缺页中断)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2010.06.10.png" alt=""></li>
<li>EAT
<ul>
<li>(1 - ρ) * memory access + p(page fault overhead + [swap page out] + swap page in + restart overhead)</li>
</ul>
</li>
</ul>
<h3 id="页表机制">页表机制</h3>
<ul>
<li>操作系统需要知道每个页面是否已经调入内存-&gt;页表</li>
<li>操作系统需要决定将哪个页面换出内存-&gt;存储某些指标
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2010.56.48.png" alt=""></li>
</ul>
<h3 id="缺页中断机构">缺页中断机构</h3>
<ul>
<li>过程
<ul>
<li>要访问的页面不在内存 valid-invalid bit</li>
<li>产生缺页中断，由操作系统的缺页中断处理程序处理中断</li>
<li>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列</li>
<li>Find the location of the desired page on disk -&gt; Find a free frame</li>
<li>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项
<ul>
<li>If there is a free frame, use it</li>
</ul>
</li>
<li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则要将其写回外存。为修改过的页面不用写回外存
<ul>
<li>If there is no free frame, user a page replacement algorithm to select a victim frame</li>
</ul>
</li>
</ul>
</li>
<li>缺页中断属于内中断
<ul>
<li>是因为当前执行的指令想要访问的目标页面未调入内存而产生的</li>
<li>属于故障(由错误条件引起，可能被故障处理程序修复)</li>
</ul>
</li>
<li>一条指令在执行期间，可能产生多次缺页中断
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2011.03.54.png" alt=""></li>
<li>比基本分页存储管理的新增步骤
<ul>
<li>请求调页</li>
<li>页面置换</li>
<li>需要修改请求页表中新增的表项</li>
</ul>
</li>
</ul>
<h3 id="逻辑地址与物理地址的转换">逻辑地址与物理地址的转换</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2011.08.34.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2011.11.56.png" alt=""></p>
<h3 id="总结-34">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2011.13.40.png" alt=""></p>
<h2 id="32_3-页面置换算法-page-replacement">3.2_3 页面置换算法 Page Replacement</h2>
<h3 id="最佳置换算法opt">最佳置换算法(OPT)</h3>
<ul>
<li>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率</li>
<li>缺页率：缺页中断发生的次数/访问页面的次数</li>
<li>前提条件
<ul>
<li>知道后续访问页面的次序</li>
</ul>
</li>
<li>理想化算法，在实际应用中无法实现
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2020.39.26.png" alt=""></li>
<li>作为其他算法的评价依据</li>
</ul>
<h3 id="先进先出算法fifo">先进先出算法(FIFO)</h3>
<ul>
<li>先进先出置换算法(FIFO)：每次选择淘汰的页面是最早进入内存的页面</li>
<li>实现算法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可</li>
<li>队列的最大长度取决于系统为进程分配了多少个内存块</li>
<li>Belady异常
<ul>
<li>当为进程分配的物理块数增大时，却也次数不减反增的异常现象</li>
</ul>
</li>
<li>只有FIFO算法会产生Belady异常(Belady&rsquo;s Anomaly)</li>
<li>实现简单，但算法性能差
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2020.46.17.png" alt="">
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2020.46.29.png" alt=""></li>
</ul>
<h3 id="最近最久未使用置换算法lru-least-recently-usedlru-algorithm">最近最久未使用置换算法(LRU) Least Recently Used(LRU) Algorithm</h3>
<ul>
<li>每次淘汰的页面是最近最近未使用的页面</li>
<li>实现方法
<ul>
<li>赋予每个页面对应的页表项，用访问字段记录该页面上自上次被访问以来所经历的时间t
<ul>
<li>Counter implementation</li>
</ul>
</li>
<li>当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面</li>
</ul>
</li>
<li>性能好，但实现困难，开销大</li>
<li>性能最接近最佳置换算法</li>
<li>实现方法
<ul>
<li>堆栈</li>
<li>引用位(二次机会)
<ul>
<li>引用时，置为1</li>
<li>查找时，将所有1置位0，替换出0</li>
<li>优点：时间少</li>
<li>缺点：没有严格按时间排序
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-19%2010.38.55.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="时钟置换算法clock">时钟置换算法(CLOCK)</h3>
<ul>
<li>性能和开销较均衡算法，又称CLOCK算法，或最近未用算法(NRU)</li>
<li>简单CLOCK算法实现
<ul>
<li>为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列</li>
<li>当某页被访问时，其访问位置为1，当需要淘汰一个页面时，只需检查页的访问位</li>
<li>如果是0，就选择将该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面</li>
<li>若第一轮扫描中所有页面都是1，则将这些页面的访问位置为0后，再进行第二轮扫描(简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描)</li>
</ul>
</li>
<li>改进型的时钟置换算法
<ul>
<li>在其他条件都相同时，应优先淘汰没有被修改过的页面</li>
<li>增加修改位，修改位=0，表示页面没有被修改过，修改位=1，表示页面被修改过</li>
<li>算法规则
<ul>
<li>第一轮：从当前位置开始扫描到的第一个访问位与修改位均为0的页面用于替换</li>
<li>第二轮：查找第一个访问位为0，修改位为1的帧用于替换，将所有扫描过的访问位设为0</li>
<li>第三轮：查找第一个访问位和修改为均为0的帧用于替换</li>
<li>第四轮，查找第一个访问位为0，修改位为1的帧用于替换</li>
<li>三、四轮扫描中，一定会选中一个页面来进行淘汰</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="lfu">LFU</h3>
<ul>
<li>Keep a counter of the number of references that hav been made to each page</li>
<li>LFU
<ul>
<li>替换count最小的页</li>
</ul>
</li>
</ul>
<h3 id="mfu">MFU</h3>
<ul>
<li>Keep a counter of the number of references that hav been made to each page</li>
<li>MFU
<ul>
<li>替换count最大的页</li>
</ul>
</li>
</ul>
<h3 id="总结-35">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2021.10.45.png" alt=""></p>
<h2 id="32_4-页面分配策略抖动工作集">3.2_4 页面分配策略、抖动、工作集</h2>
<h3 id="驻留集">驻留集</h3>
<ul>
<li>指请求分页存储管理中给进程分配的物理块的集合</li>
<li>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</li>
<li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；若驻留集太大，又会导致多道程序并发度下降，资源利用率降低</li>
</ul>
<h3 id="页面分配置换策略">页面分配、置换策略</h3>
<ul>
<li>帧分配算法
<ul>
<li>固定分配 fixed allocation
<ul>
<li>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，驻留集大小不变</li>
</ul>
</li>
<li>Proportional allocation
<ul>
<li>根据进程的大小分配</li>
<li>按比例</li>
</ul>
</li>
<li>Priority Allocation
<ul>
<li>根据优先级分配</li>
</ul>
</li>
<li>可变分配
<ul>
<li>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况作适当的增加或减少，即，驻留集大小可变</li>
</ul>
</li>
</ul>
</li>
<li>置换范围策略
<ul>
<li>局部置换
<ul>
<li>发生缺页时只能选进程自己的物理块进行置换</li>
</ul>
</li>
<li>全局置换
<ul>
<li>可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</li>
</ul>
</li>
</ul>
</li>
<li>固定分配只能局部置换；可变分配及可以局部置换也可以全局置换</li>
<li>固定分配局部置换
<ul>
<li>缺点：很难在刚开始就确定为每个进程分配多少物理块才算合理</li>
</ul>
</li>
<li>可变分配全局置换
<ul>
<li>缺点：被选中的调出内存的物理块所属的进程拥有的物理块会减少，缺页率增加</li>
</ul>
</li>
</ul>
<blockquote>
<p>锁定：系统会锁定一些页面，这些页面中的内容不能只换出外存</p>
</blockquote>
<ul>
<li>可变分配局部置换
<ul>
<li>只允许进程从自己的物理块选出一个换出外存</li>
<li>如果进程在运行中频繁的缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度</li>
<li>如果进程在运行中缺页率特别低，可适当间洒红分配给该进程的物理块</li>
</ul>
</li>
</ul>
<h3 id="调入页面的时机">调入页面的时机</h3>
<ul>
<li>预调页策略
<ul>
<li>一次调入若刚呃相邻的页面可能比一次调入一个页面更高效</li>
<li>预测不久之后可以访问到的页面，将其预先调入内存</li>
<li>但目前预测成功率只有50%左右</li>
<li>主要用于进程的首次调入，由程序员指出应该先调入哪些部分</li>
<li>运行前调入</li>
</ul>
</li>
<li>请求调页策略
<ul>
<li>进程在运行期间发现缺页时才讲所缺页面调入内存</li>
<li>有这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大</li>
</ul>
</li>
</ul>
<h3 id="从何处调入页面">从何处调入页面</h3>
<ul>
<li>对换区
<ul>
<li>连续分配方式</li>
<li>读/写速度更快</li>
</ul>
</li>
<li>文件区
<ul>
<li>离散分配方式</li>
<li>读/写速度更慢</li>
</ul>
</li>
</ul>
<ol>
<li>系统拥有足够的对换区空间</li>
</ol>
<ul>
<li>页面的调入、调取都是在内存与对换区之间进行</li>
</ul>
<ol start="2">
<li>系统中缺少足够的对换区空间
<ul>
<li>凡是不会被修改的数据都直接从文件区调入
<ul>
<li>换出时不必写回磁盘，下次需要时再从文件区调入即可</li>
</ul>
</li>
<li>可能修改的部分
<ul>
<li>换出时需写回磁盘对换区，下次需要时再从对换区调入</li>
</ul>
</li>
</ul>
</li>
<li>UNIX方式
<ul>
<li>运行之前进程有关的数据全部存放在文件区，故未使用过的页面，都可以从文件区调入</li>
<li>若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</li>
</ul>
</li>
</ol>
<h3 id="抖动颠簸现象-thrashing">抖动(颠簸)现象 Thrashing</h3>
<ul>
<li>频繁的页面调度行为</li>
<li>原因：进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</li>
</ul>
<h3 id="进程工作集-wss_i-working-set-of-process-p_i">进程工作集 $WSS_i$ working set of Process $P_i$</h3>
<ul>
<li>工作集：在某段时间间隔里，进程实际访问页面的集合</li>
<li>工作集带下可能小于窗口尺寸。实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块
<ul>
<li>Keeping Track of the Working Set</li>
<li>Establish “acceptable” page-fault rate.
<ul>
<li>If actual rate too low, process loses frame.</li>
<li>If actual rate too high, process gains frame.</li>
</ul>
</li>
</ul>
</li>
<li>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</li>
</ul>
<h3 id="总结-36">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2021.35.17.png" alt=""></p>
<h2 id="32_5-内存映射文件">3.2_5 内存映射文件</h2>
<ul>
<li>操作系统向上层程序员提供的功能
<ul>
<li>方便程序员访问文件数据</li>
<li>方便多个进程共享同一个文件</li>
</ul>
</li>
</ul>
<h3 id="传统的文件访问方式">传统的文件访问方式</h3>
<ul>
<li>open 系统调用——打开文件</li>
<li>seek 系统调用——把读写指针移到某个位置</li>
<li>read 系统调用——从读写指针所指位置读入若干数据(从磁盘读入内存)</li>
<li>write 系统调用——将内存中的指定数据写回磁盘</li>
</ul>
<h3 id="内存映射文件的访问方式">内存映射文件的访问方式</h3>
<ul>
<li>open 系统调用——打开文件</li>
<li>mmap 系统调用——将文件映射到进程的虚拟地址空间
<ul>
<li>以访问内存的方式访问数据
<ul>
<li>建立文件数据和内存之间的映射关系，并没有把文件数据读入内存</li>
</ul>
</li>
<li>文件的读入、写出由操作系统自动完成</li>
<li>进程<strong>关闭文件</strong>时，操作系统自动<strong>将文件被修改的数据写回磁盘</strong></li>
</ul>
</li>
</ul>
<h3 id="可以实现文件数据的共享">可以实现文件数据的共享</h3>
<ul>
<li>多个进程映射同一个文件，实现共享</li>
<li>在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个进程可以立马“看到”</li>
</ul>
<h3 id="allocating-kernel-memory">Allocating Kernel Memory</h3>
<ul>
<li>Buddy System Allocator
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-26%2010.02.51.png" alt=""></li>
<li>Slab Allocation
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-26%2010.03.41.png" alt=""></li>
<li>Prepaging
<ul>
<li>at process startup</li>
<li>Prepage all or some of the pages a process will need, before they are referenced</li>
<li>But if prepaged pages are unused, I/O and memory was wasted</li>
</ul>
</li>
</ul>
<blockquote>
<p>页面增大(唯一的缺点是浪费了空间)
碎片增大
页表减小
I/O次数越少
局部性越好</p>
</blockquote>
<ul>
<li>TLB
<ul>
<li>TLB Reach = (TLB Size) X (Page Size)</li>
<li>Ideally, the working set of each process is stored in the TLB. Otherwise there is a high degree of page faults.</li>
<li>缺页率会受程序结构的影响</li>
</ul>
</li>
<li>I/O Interlock
<ul>
<li>Pages that are used for copying a file from a device must be locked from being selected for eviction by a page replacement algorithm.</li>
</ul>
</li>
</ul>
<h3 id="总结-37">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-07%2021.45.23.png" alt=""></p>
<h1 id="第四章-文件管理">第四章 文件管理</h1>
<h2 id="41_1-初识文件管理-file-system-inerface">4.1_1 初识文件管理 File-System inerface</h2>
<ul>
<li>文件——一组有意义的信息/数据集合
<ul>
<li>文件内部的数据应该怎样组织起来(存放在外存)</li>
<li>文件之间又应该怎么组织起来</li>
</ul>
</li>
</ul>
<h3 id="文件属性">文件属性</h3>
<ul>
<li>文件名
<ul>
<li>主要是方便用户找到文件</li>
<li>同一目录下不允许有重名文件</li>
</ul>
</li>
<li>标识符
<ul>
<li>系统内的个文件标识符唯一</li>
<li>对用户来说毫无可读性</li>
<li>标识符只是操作系统用于区分各个文件的一种内部名称</li>
</ul>
</li>
<li>类型
<ul>
<li>指明文件的类型</li>
</ul>
</li>
<li>位置
<ul>
<li>文件存放的路径(让用户使用)</li>
<li>外存中的地址(操作系统使用，对用户不可见)</li>
</ul>
</li>
<li>大小</li>
<li>创建时间、上次修改信息</li>
<li>文件所有者信息</li>
<li>保护信息：对文件进行保护的访问控制信息</li>
</ul>
<h3 id="文件内部的数据应该怎样组织起来">文件内部的数据应该怎样组织起来</h3>
<ul>
<li>无结构的文件(如文本文件)
<ul>
<li>由一些二进制或字符流组成，又称“流式文件”</li>
</ul>
</li>
<li>有结构文件(如数据库表, excel) 定长/变长
<ul>
<li>由一组相似的记录组成，又称“记录式文件”</li>
<li>记录是一组相关数据项的结合</li>
<li>数据项是文件系统中最基本的数据单位</li>
</ul>
</li>
</ul>
<h3 id="文件之间又应该怎么组织起来">文件之间又应该怎么组织起来</h3>
<ul>
<li>根目录
<ul>
<li>子目录
<ul>
<li>子目录</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>目录：文件夹
一种特殊的有结构文件(由记录组成)</p>
</blockquote>
<h3 id="操作系统应该向上提供哪些功能">操作系统应该向上提供哪些功能</h3>
<ul>
<li>创建文件
<ul>
<li>点击新建后</li>
<li>create</li>
</ul>
</li>
<li>读文件
<ul>
<li>将文件数据读入内存</li>
<li>让CPU处理</li>
<li>read系统调用</li>
</ul>
</li>
<li>写文件
<ul>
<li>write系统调用</li>
<li>把文件数据从内存写回外存</li>
<li>平时的修改仅仅修改内存中的数据</li>
</ul>
</li>
<li>删除文件
<ul>
<li>delete系统调用</li>
</ul>
</li>
<li>打开文件
<ul>
<li>open系统调用</li>
</ul>
</li>
<li>关闭文件
<ul>
<li>close系统调用</li>
</ul>
</li>
</ul>
<blockquote>
<p>读/写文件之前，需要“打开文件”
读/写文件结束之后，需要“关闭文件”</p>
</blockquote>
<ul>
<li>文件共享
<ul>
<li>使多个用户可以共享使用一个文件</li>
</ul>
</li>
<li>文件保护
<ul>
<li>不同的用户对文件有不同的操作权限</li>
</ul>
</li>
</ul>
<h3 id="文件应该如何存放在外存">文件应该如何存放在外存</h3>
<ul>
<li>外存也是由一个个存储单元组成，每个存储单元可以存储一定量的数据(如1B)，<strong>每个存储单元对应一个物理地址</strong></li>
<li>外存会分为一个个“块/磁盘块/物理块”，每个磁盘块的大小是相等的，每块一般包含2的整数幂个地址；文件的逻辑地址也可以分为(逻辑块号，块内地址)</li>
<li>操作系统以“块”为单位为文件分配存储空间，因此即使一个文件大小只有10B，但它依然需要占用1KB的磁盘块，外存中的数据读入时同样以块为单位</li>
</ul>
<h3 id="总结-38">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-08%2021.18.44.png" alt=""></p>
<h2 id="41_2-文件的逻辑结构">4.1_2 文件的逻辑结构</h2>
<blockquote>
<p>文件的逻辑结构：在用户看来，文件内部的数据应该是如何组织起来的
文件的物理结构：在操作系统看来，文件的数据是如何存放在外存中的</p>
</blockquote>
<h3 id="无结构文件">无结构文件</h3>
<ul>
<li>文件内部的数据由一系列二进制流或字符流组成，又称“流式文件”</li>
<li>文件内部的数据其实就是一系列字符流，没有明显的结构特性</li>
</ul>
<h3 id="有结构文件">有结构文件</h3>
<ul>
<li>由一组相似的记录组成，又称“记录式文件”</li>
<li>每条记录又由若干个数据项组成
<ul>
<li>一般来说，每条记录有一个数据项可作为关键字</li>
<li>定长记录/可变长记录</li>
</ul>
</li>
</ul>
<h3 id="有结构文件的逻辑结构">有结构文件的逻辑结构</h3>
<ul>
<li><strong>顺序文件</strong>
<ul>
<li>一般指顺序存储的顺序文件</li>
<li>文件中的记录一个接一个地顺序排列(逻辑上)</li>
<li>记录可以是定长的或可变长的</li>
<li>各个记录在物理上可以顺序存储或链式存储</li>
</ul>
</li>
</ul>
<blockquote>
<p>顺序存储——逻辑上相邻的记录物理上也相邻 <strong>可变长记录无法实现随机存取</strong> <strong>定长记录可以实现随机存取</strong>
链式存储——逻辑上相邻的记录物理上不一定相邻 <strong>无法实现随机存取</strong></p>
</blockquote>
<ul>
<li>
<p>分类</p>
<ul>
<li>串结构：记录之间的顺序与关键字无关(通常按照记录存入的时间决定记录的顺序) <strong>无法快速找到某关键字对应的记录</strong></li>
<li>顺序结构：记录之间的顺序按关键字顺序排列 <strong>可以快速找到某关键字对应的记录(如折半查找)</strong></li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>顺序结构增加/删除一个记录比较困难(串结构比较简单)</li>
</ul>
</li>
<li>
<p>一般来说，系统会管理一个日志文件，每隔一段时间将其写入外存</p>
</li>
<li>
<p>索引文件</p>
<ul>
<li>使可变长记录文件实现随机存取</li>
<li>建立一张<strong>索引表</strong>以加快文件检索速度，每条记录对应一个索引项</li>
<li>文件中的这些记录在<strong>物理上可以离散地存放</strong></li>
<li>索引表本身是<strong>定长记录</strong>的<strong>顺序文件</strong></li>
<li>可将关键字作为索引号内容，支持折半查找</li>
<li>主要用于对信息处理的及时性要求比较高的场合</li>
<li>可以用不同的数据项建立多个索引表</li>
</ul>
</li>
<li>
<p>索引顺序文件</p>
</li>
</ul>
<blockquote>
<p>索引文件的缺点：索引表可能会很大，空间利用率降低</p>
</blockquote>
<ul>
<li>一组记录对应一个索引表项</li>
<li>索引项串结构存储</li>
<li>可建立<strong>多级索引表</strong></li>
</ul>
<h3 id="总结-39">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-08%2021.52.28.png" alt=""></p>
<h2 id="41_3-文件目录">4.1_3 文件目录</h2>
<ul>
<li>文件之间的组织结构清晰，易于查找</li>
<li>编程时也可以很方便的用文件路径找到一个文件，用户可以轻松实现存储</li>
</ul>
<h3 id="文件控制块">文件控制块</h3>
<ul>
<li>目录
<ul>
<li>目录本身就是一种结构文件，由一条条记录组成</li>
<li>每条记录对应一个放在该目录下的文件</li>
<li>双击文件后，操作系统会在这个目录表中找到文件对应的目录项(也就是记录)，然后从外存中将文件的目录的信息读入内存</li>
<li>目录文件中的一条记录就是一个“文件控制块”(FCB)</li>
<li>最重要，最基本的还是<strong>文件名、文件存放的物理地址</strong>
<ul>
<li>用户“按名存取”</li>
</ul>
</li>
</ul>
</li>
<li>对目录进行的操作
<ul>
<li>搜索</li>
<li>创建文件
<ul>
<li>在其所属的目录中增加一个目录项</li>
</ul>
</li>
<li>删除文件
<ul>
<li>在目录中删除相应的目录项</li>
</ul>
</li>
<li>显示目录
<ul>
<li>显示目录中的所有文件及其相应属性</li>
</ul>
</li>
<li>修改目录
<ul>
<li>属性变化时需要修改相应的目录项</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="目录结构">目录结构</h3>
<ul>
<li>单级目录结构
<ul>
<li>实现“按名存取”，不允许文件重名</li>
<li>创建一个文件时，先检查有没有重名文件</li>
<li>单机目录结构不适于多用户操作系统</li>
</ul>
</li>
<li>两级目录结构
<ul>
<li>主文件目录 MFD(Master File Directory)
<ul>
<li>用户名及相应用户文件目录的存放位置</li>
</ul>
</li>
<li>用户文件目录 UFD(User File Directory)
<ul>
<li>由该用户的文件FCB组成</li>
<li>允许不同用户的文件重名</li>
<li>可以在目录上实现访问限制，检查此时登陆的用户名是否匹配</li>
<li>仍然缺乏灵活性，用户不能对自己的文件进行分类</li>
</ul>
</li>
</ul>
</li>
<li>多级目录结构(树形目录结构)
<ul>
<li>用户(或用户进程)要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串</li>
<li>各级目录之间用&quot;/&ldquo;隔开，从根目录出发的路径称为<strong>绝对路径</strong></li>
<li>系统根据绝对路径一层一层地找到下一级目录
<ul>
<li>刚开始从外存读入根目录的目录表</li>
<li>依次读取每层目录表</li>
</ul>
</li>
<li>可以设置一个“<strong>当前目录</strong>”，从当前目录出发的路径称为<strong>相对路径</strong></li>
<li>引入当前目录和相对路径后，可减少磁盘I/O数目</li>
<li>树形结构<strong>不便于实现文件的共</strong>享</li>
</ul>
</li>
<li>无环图目录结构
<ul>
<li>在树形目录结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图，可以更方便的实现多个用户间的文件共享</li>
<li>可以用不同的文件名指向通过同一个文件，甚至可以指向同一个目录(共享统一目录下的所有内容)</li>
<li>需要为每个共享节点设置一个<strong>共享计数器</strong>，用于记录此时有多少个地方在共享该结点；
<ul>
<li>用户提出删除节点的请求时，只是删除该用户的FCB，并使共享计数器减1，并不会直接删除共享节点；</li>
<li>共享计数器减为0时，才删除节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>共享文件≠复制文件
一个用户修改了数据之后，所有用户都可以看到文件数据的变化</p>
</blockquote>
<h3 id="索引结点fcb的改进">索引结点(FCB的改进)</h3>
<ul>
<li>索引节点
<ul>
<li>除了文件名之外的文件描述信息</li>
</ul>
</li>
<li>目录中只包含文件名和索引节点指针</li>
<li>提升文件检索速度</li>
</ul>
<blockquote>
<p>磁盘索引节点：存放在外存中的索引节点
内存索引节点：存放在内存中的索引节点。需要增加信息，记录文件是否被修改、有几个进程正在访问等信息
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-09%2011.30.54.png" alt=""></p>
</blockquote>
<h2 id="41_45-文件的物理结构">4.1_4/5 文件的物理结构</h2>
<ul>
<li>即文件分配方式</li>
<li>文件的逻辑地址被分为了一个一个的“块”</li>
<li>逻辑地址也可以表示为(逻辑块号，块内地址)的形式</li>
</ul>
<h3 id="连续分配">连续分配</h3>
<ul>
<li>每个文件在磁盘上占有一组<strong>连续的块</strong>
<ul>
<li>读取某个磁盘块时，需要移动磁头，访问的两个磁盘块相隔越远，移动磁头所需时间越长</li>
</ul>
</li>
<li>(逻辑块号，块内地址)-&gt;(物理块号，块内地址)
<ul>
<li>FCB-&gt;物理块号=起始块号+逻辑块号</li>
<li>用户还需检查用户提供的逻辑块号是否合法</li>
</ul>
</li>
<li>优点
<ul>
<li>连续分配支持顺序访问和直接访问(随机访问)</li>
<li>连续分配的文件在顺序读/写时速度最快</li>
</ul>
</li>
<li>缺点
<ul>
<li>物理上采用连续分配的文件不方便拓展</li>
<li>物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片</li>
<li>可以用紧凑来处理碎片，但是需要消耗很大的代价</li>
</ul>
</li>
</ul>
<h3 id="链接分配一般默认隐式链接">链接分配(一般默认隐式链接)</h3>
<ul>
<li>隐式链接
<ul>
<li>链接分配采取离散分配方式，可以为文件分配离散的磁盘块
<ul>
<li>目录中记录了文件存放的起始块号和结束块号，也可以增加一个字段用来表示文件的长度</li>
<li>除了文件的最后一个磁盘块之外，每个磁盘块都会保存指向下一个盘块的指针，这些指针对用户是透明的</li>
</ul>
</li>
<li>用户给出逻辑块号i-&gt;操作系统找到该文件对应的目录项PCB-&gt;从目录项中找到起始块号，读入内存-&gt;依次将每块读入内存
<ul>
<li>用户读入i号逻辑块，总共需要i+1次I/O操作</li>
</ul>
</li>
<li>缺点
<ul>
<li>只支持顺序访问，不支持随机访问，<strong>查找效率低</strong></li>
<li>指向下一个盘块的指针也需要耗费少量的存储空间</li>
</ul>
</li>
<li>优点
<ul>
<li>很方便文件拓展，不会有碎片问题，外存利用率高</li>
</ul>
</li>
</ul>
</li>
<li>显式链接
<ul>
<li>文件分配表FAT
<ul>
<li>把用于连接各文件各物理块的指针显式地存放在一张表中</li>
<li>显式记录链接关系</li>
<li>物理块号+下一块</li>
</ul>
</li>
<li><strong>一个磁盘</strong>仅设置<strong>一张FAT</strong>
<ul>
<li>开机时，将FAT读入内存，并<strong>常驻内存</strong></li>
<li>各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”可以是隐含的</li>
</ul>
</li>
<li>逻辑块号-&gt;物理块号
<ul>
<li>从目录项中找到起始块号，若i &gt; 0，则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号。</li>
<li>逻辑块号转换成物理块号的过程不需要读磁盘操作</li>
</ul>
</li>
<li>优点
<ul>
<li>支持顺序访问，也<strong>支持随机访问</strong></li>
<li>不会产生外部碎片</li>
<li>不需要访问磁盘，文件的访问效率更高</li>
</ul>
</li>
<li>缺点
<ul>
<li>文件分配表需要占用一定的存储空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="索引分配">索引分配</h3>
<ul>
<li>允许文件离散地分配在各个磁盘中，系统会为<strong>每个文件</strong>建立<strong>一张索引表</strong>，索引表中记录了文件的各个逻辑块对应的物理块</li>
<li>FCB中记录文件的索引块是几号磁盘块</li>
</ul>
<blockquote>
<p>索引块：索引表存放的磁盘
数据块：文件数据存放的磁盘</p>
</blockquote>
<ul>
<li>可以用固定的长度表示物理块号，因此，索引表中的“逻辑块号”可以是隐含的</li>
<li>逻辑块号-&gt;物理块号
<ul>
<li>用户给出要访问的逻辑块号i，操作系统找到该文件对应的目录项(FCB)，找到文件的索引块块号</li>
<li>从索引表读入内存，查找索引表-&gt;得到i号或几块在外存中的存放位置</li>
</ul>
</li>
<li>优点
<ul>
<li>可以支持随机访问</li>
<li>容易实现文件拓展</li>
</ul>
</li>
<li>缺点
<ul>
<li>索引表需要占用一定的存储空间</li>
</ul>
</li>
<li>一个磁盘块装不下文件的整张索引表，如何解决？
<ul>
<li><strong>链接方案</strong>
<ul>
<li>将多个索引块连接起来存放</li>
<li>系统必须顺序的读取各个索引表</li>
</ul>
</li>
<li><strong>多层索引</strong>
<ul>
<li>建立多层索引</li>
<li>第一层索引块指向第二层索引块</li>
<li>还可以根据文件大小的要求再建立第三层、第四层索引块</li>
<li>若采用多层索引，则各层索引表的大小不能超过一个磁盘块</li>
<li>逻辑地址-&gt;物理地址
<ul>
<li>依次调入每级索引表</li>
</ul>
</li>
<li>缺点：对逻辑地址较小的块仍然需要依次访问多级索引表</li>
</ul>
</li>
<li><strong>混合索引</strong>
<ul>
<li>多种索引分配方式的结合
<ul>
<li>一个文件的顶级索引表中，既包含直接地址索引(直接指向数据块)</li>
<li>又包含一级间接索引(指向单层索引表)</li>
<li>还包含两级间接索引(指向两层索引表)</li>
</ul>
</li>
<li>优点
<ul>
<li>对于小文件，只需较少的读磁盘次数就可以访问目标数据块(一般计算机中小文件更多)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="考点">考点</h3>
<ul>
<li>根据多层索引、混合索引的结构计算出文件的最大长度(<strong>各级索引表最大不能超过一个块</strong>)</li>
<li>要能自己分析访问某个数据块所需要的读磁盘次数(<strong>FCB</strong>中会存有<strong>指向顶级索引块的指针</strong>，因此可以根据FCB读入定级索引块。每次读入下一季的索引块都需要一次读磁盘操作。注意题目条件——<strong>顶级索引块是否已调入内存</strong>)</li>
</ul>
<h3 id="总结-40">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-09%2021.05.04.png" alt=""></p>
<h2 id="41_5-逻辑结构vs物理结构">4.1_5 逻辑结构vs物理结构</h2>
<h3 id="逻辑结构">逻辑结构</h3>
<ul>
<li>C语言
<ul>
<li>fseek 将文件的读写指针移动到某位置
<ul>
<li>fseek(fp, 16, SEEK_SET)</li>
</ul>
</li>
<li>FILE *fp = fopen(&ldquo;test.txt&rdquo;, &ldquo;r&rdquo;);</li>
<li>char c = fgetc(fp);</li>
<li>fclose(fp);</li>
</ul>
</li>
<li>用户用逻辑地址访问文件</li>
</ul>
<h3 id="物理结构">物理结构</h3>
<ul>
<li>fseek指明逻辑地址</li>
<li>fgetc底层使用了Read系统调用，操作系统将(逻辑块号，块内偏移量)转换为(物理块号，块内偏移量)</li>
</ul>
<h3 id="总结-41">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-10%2010.34.13.png" alt=""></p>
<h2 id="41_6-文件存储空间管理">4.1_6 文件存储空间管理</h2>
<h3 id="存储空间的划分与初始化">存储空间的划分与初始化</h3>
<ul>
<li>存储空间的划分
<ul>
<li>将物理磁盘划分为一个个文件卷(逻辑卷、逻辑盘)</li>
</ul>
</li>
<li>存储空间的初始化
<ul>
<li>将各个文件卷划分为目录区、文件区
<ul>
<li>目录区主要存放文件目录信息(FCB)，用于磁盘存储空间管理的信息</li>
<li>文件区用于存放文件数据</li>
</ul>
</li>
<li>有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷</li>
</ul>
</li>
</ul>
<h3 id="几种管理方法">几种管理方法</h3>
<ul>
<li>空闲表法
<ul>
<li>适用于“连续分配方式”</li>
<li>为一个文件分配连续的存储空间
<ul>
<li>可采用首次适应、最佳适应、最坏适应等肃反啊来决定要为文件分配哪个区间</li>
</ul>
</li>
<li>如何回收磁盘块
<ul>
<li>回收区前后都没有相邻空闲区(增加表项)</li>
<li>回收区前后都是空闲区(合并，表项数量减少一个)</li>
<li>回收区前面是空闲区(合并)</li>
<li>回收区后面是空闲区(合并)</li>
</ul>
</li>
</ul>
</li>
<li>空闲链表法
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-10%2010.46.35.png" alt="">
<ul>
<li>空闲盘块链
<ul>
<li>操作系统保存着链头、链尾指针</li>
<li>如何分配：文件申请K个盘块，从链头开始依次摘下K个盘块分配，并修改空闲链的链头指针</li>
<li>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针</li>
<li>适用于离散分配的物理结构，为文件分配多个盘块是可能要重复多次操作</li>
</ul>
</li>
<li>空闲盘区链
<ul>
<li>操作系统保存着链头、链尾指针</li>
<li>如何分配：从链头开始检索，采用首次适应、最佳适应等算法，找到合适的空闲盘区，分配给文件</li>
<li>如何回收：注意合并</li>
<li>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</li>
</ul>
</li>
</ul>
</li>
<li>存储空间管理——位示图法
<ul>
<li>位示图
<ul>
<li>每个二进制对应一个盘块</li>
<li>位示图一般用连续的“字”来表示，可以用(字号，位号/行号，列号)对应一个盘块号</li>
<li>(i, j) -&gt; 盘块号b = n * i + j</li>
</ul>
</li>
<li>如何分配：若文件需要K个块，顺序扫描位示图，找到K个相邻或不相邻的“0”；根据字号、位号算出对应的盘块号，将相应盘块分配给文件，将相应位设置为“1”(已分配状态)</li>
<li>如何回收：根据回收的盘块号计算出对应的字号、位号，将相应的二进制设为“0”</li>
<li>连续分配、离散分配都适用</li>
</ul>
</li>
<li>存储空间管理——成组链接法
<ul>
<li>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大</li>
<li>UNIX采用了<strong>成组链接法</strong>对磁盘空闲块进行管理</li>
<li><strong>超级块</strong>：文件卷的目录中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存，并且要保证内存与外存中的“超级块”数据一致</li>
<li>超级块中存储下一组空闲盘块数和空闲块号，一个分组中的块号不需要连续</li>
<li>如何分配
<ul>
<li>检查超级块中下一组空闲盘块数是否足够</li>
<li>如果足够的话，分配下一组空闲块中的空闲块，并减少本超级块中记录的下一组空闲块数</li>
<li>如果要把一个分组中的所有空闲块全部分配出去，应该把这个分组的超级块中的数据全部复制到超级块中</li>
</ul>
</li>
<li>如何回收
<ul>
<li>增加分组时，需要讲超级开中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块称为第一个分组</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="41_7-文件的基本操作">4.1_7 文件的基本操作</h2>
<h3 id="创建文件create系统调用">创建文件(create系统调用)</h3>
<ul>
<li>create系统调用需要的参数
<ul>
<li>所需的外存空间大小</li>
<li>文件存放路径</li>
<li>文件名(默认为新建文本文档.txt)</li>
</ul>
</li>
<li>操作系统主要做的事情
<ul>
<li>在外存中找到文件所需的空间</li>
<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息</li>
</ul>
</li>
</ul>
<h3 id="删除文件delete系统调用">删除文件(delete系统调用)</h3>
<ul>
<li>delete系统调用需要的参数
<ul>
<li>文件存放路径</li>
<li>文件名</li>
</ul>
</li>
<li>操作系统主要做的事情
<ul>
<li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项</li>
<li>根据该目录项记录的文件在外存中的存放位置、文件大小等信息，回收文件占用的磁盘块</li>
<li>从目录表中删除文件对应的目录项</li>
</ul>
</li>
</ul>
<h3 id="打开文件open系统调用">打开文件(open系统调用)</h3>
<ul>
<li>参数
<ul>
<li>文件存放路径</li>
<li>文件名</li>
<li>要对文件的操作类型</li>
</ul>
</li>
<li>操作系统主要做的事情
<ul>
<li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限</li>
<li>将目录项复制到内存中的“打开文件表”中，并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件
<ul>
<li>之后用户进程再操作问价就不需要每次都重新查目录了，这样可以加快文件的访问速度</li>
</ul>
</li>
</ul>
</li>
<li>打开文件表
<ul>
<li>用户进程的打开文件表
<ul>
<li>系统表索引号</li>
<li>读写指针：记录进程对文件的读/写操作进行到的位置</li>
<li>访问权限：表明进程对文件的访问权限</li>
</ul>
</li>
<li>系统的打开文件表(整个系统只有一张)
<ul>
<li>打开计数器(有多少个进程打开了次文件)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关闭文件close系统调用">关闭文件(close系统调用)</h3>
<ul>
<li>参数
<ul>
<li>将进程的打开文件表相应表项删除</li>
<li>回收分配给该文件的内存空间等资源</li>
<li>系统打开文件表的打开计数器count减1，若count = 0，则删除对应表项</li>
</ul>
</li>
</ul>
<h3 id="读文件read系统调用">读文件(read系统调用)</h3>
<ul>
<li>指明是哪个文件
<ul>
<li>在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号(<strong>文件描述符</strong>)即可</li>
</ul>
</li>
<li>还需要指明要读入多少数据、指明读入的数据要存放在内存中的什么位置</li>
<li>操作系统会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中</li>
</ul>
<h3 id="写文件write系统调用">写文件(write系统调用)</h3>
<ul>
<li>指明是哪个文件
<ul>
<li>在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号(<strong>文件描述符</strong>)即可</li>
</ul>
</li>
<li>指明要写出多少数据</li>
<li>写回外存的数据放在内存中的什么位置</li>
<li>从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</li>
</ul>
<h3 id="总结-42">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2008.38.23.png" alt=""></p>
<h2 id="41_8-文件共享">4.1_8 文件共享</h2>
<ul>
<li>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件</li>
<li>多个用户共享同一个文件，意味着系统中只有“一份”文件数据</li>
<li>只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化</li>
<li>区分共享与复制</li>
</ul>
<h3 id="基于索引节点的共享方式硬链接">基于索引节点的共享方式(硬链接)</h3>
<ul>
<li>索引节点中设置一个链接计数变量count，用于表示链接到本索引节点上的用户目录项数</li>
<li>不同用户对同一个文件起的文件名可以不同</li>
<li>用户删除文件时，只需要把用户目录中与该文件对应的目录项删除，且索引节点的count值减1
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2008.51.52.png" alt=""></li>
</ul>
<h3 id="基于符号链的共享方式软链接">基于符号链的共享方式(软链接)</h3>
<ul>
<li>Link类型的文件，记录想要共享文件的存放路径，根据路径寻找文件
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2008.54.05.png" alt=""></li>
<li>可以给Link类型的文件随机取名</li>
<li>删除文件后，软链接失效
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2008.57.35.png" alt=""></li>
</ul>
<h2 id="41_9-文件保护">4.1_9 文件保护</h2>
<h3 id="口令保护">口令保护</h3>
<ul>
<li>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”</li>
<li>一般存放在文件对应的FCB或索引节点中</li>
<li>优点
<ul>
<li>保存口令的空间开销不多</li>
<li>验证口令的时间开销也很小</li>
</ul>
</li>
<li>缺点
<ul>
<li>正确的“口令”存放在系统内部，不够安全</li>
</ul>
</li>
</ul>
<h3 id="加密保护">加密保护</h3>
<ul>
<li>使用“密码”对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密</li>
<li>最简单的加密算法：异或加密</li>
<li>优点
<ul>
<li>保密性强，不需要在系统中存储“密码”</li>
</ul>
</li>
<li>缺点
<ul>
<li>编码/译码，或者说加密/解密要花费一定时间</li>
</ul>
</li>
</ul>
<h3 id="访问控制">访问控制</h3>
<ul>
<li>在每个文件的FCB(或索引节点)中增加一个访问控制表，该表中记录了各个用户对该文件执行哪些操作</li>
<li>访问类型
<ul>
<li>读</li>
<li>写</li>
<li>执行：将文件装入内存并执行</li>
<li>添加：将新信息添加到文件结尾部分</li>
<li>删除：删除文件，释放空间</li>
<li>列表清单：列出文件名和文件属性</li>
</ul>
</li>
<li>精简的访问控制表
<ul>
<li>以“组”为单位，标记各“组”用户可以对文件执行哪些操作</li>
<li>用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限</li>
</ul>
</li>
</ul>
<h3 id="总结-43">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-12%2009.10.33.png" alt=""></p>
<h2 id="43_1-文件系统的层次结构">4.3_1 文件系统的层次结构</h2>
<h3 id="用户应用程序">用户/应用程序</h3>
<h3 id="用户接口">用户接口</h3>
<ul>
<li>文件系统需要向上层的用户提供一些简单易用的功能接口</li>
<li>用预处理用户发出的系统调用请求</li>
</ul>
<h3 id="文件目录系统">文件目录系统</h3>
<ul>
<li>用户是通过文件路径来访问文件的</li>
<li>这一层需要根据用户给出的文件路径找到相应的FCB或索引节点</li>
<li>所有和目录、目录项相关的管理工作都在本层完成
<ul>
<li>管理活跃的文件目录表</li>
<li>管理打开的文件表</li>
</ul>
</li>
</ul>
<h3 id="存取控制模块">存取控制模块</h3>
<ul>
<li>文件保护</li>
</ul>
<h3 id="逻辑文件系统与文件信息缓冲区">逻辑文件系统与文件信息缓冲区</h3>
<ul>
<li>用户指明想要访问文件记录号</li>
<li>这一层需要将记录号转换为对应的逻辑地址</li>
</ul>
<h3 id="物理文件系统">物理文件系统</h3>
<ul>
<li>把上一层提供的文件逻辑地址转换为实际的物理地址</li>
</ul>
<h3 id="最底层">最底层</h3>
<ul>
<li>辅助分配模块：负责文件存储空间的管理，负责分配和回收存储空间</li>
<li>设备管理模块：直接与硬件交互，负责和硬件直接相关的一些管理工作(如分配设配、分配设备缓冲区、磁盘调度、启动设备、释放设备等)
<ul>
<li>设备</li>
</ul>
</li>
</ul>
<h3 id="总结-44">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-14%2010.20.54.png" alt=""></p>
<h2 id="43_2-文件系统的全局结构布局">4.3_2 文件系统的全局结构(布局)</h2>
<ul>
<li>物理格式化，即低级格式化
<ul>
<li>划分扇区，检测坏扇区，并用备用扇区替换坏扇区</li>
</ul>
</li>
<li>逻辑格式化
<ul>
<li>磁盘分区(分卷Volume)</li>
<li>完成各分区的文件系统初始化</li>
</ul>
</li>
<li>文件系统在外存中的结构
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-14%2010.28.40.png" alt=""></li>
<li>文件系统在内存中的结构
<ul>
<li>目录的缓存
<ul>
<li>近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度</li>
</ul>
</li>
<li>系统打开文件表
<ul>
<li>每个系统只有一张</li>
</ul>
</li>
<li>进程打开文件表
<ul>
<li>每个进程有一张
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-14%2010.36.08.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="43_3-虚拟文件系统文件系统的挂载">4.3_3 虚拟文件系统&amp;文件系统的挂载</h2>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-15%2009.13.08.png" alt=""></p>
<ul>
<li>虚拟文件系统(VFS)的特点
<ul>
<li>向上层用户进程提供通过统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异(Linux中用POSIX标准接口)</li>
<li>VFS要求下层的文件系统功能必须实现某些规定的函数功能，如open/read/write
<ul>
<li>一个新的文件系统想要在某些操作系统上被使用，就必须满足该操作系统的VFS的要求</li>
</ul>
</li>
<li>每打开一个文件, VFS就在主存中新建一个vnode(v结点)，用统一的数据结构表示文件，无论该文件存储在哪个文件系统
<ul>
<li>vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储</li>
<li>UFS文件系统的目录项 文件名+i节点号</li>
<li>将inode从外存读入主存，并将inode的信息复制到vnode中</li>
<li>vnode中记录函数功能指针指向对应文件系统的函数功能列表</li>
</ul>
</li>
</ul>
</li>
<li>文件系统挂载 mounting
<ul>
<li>文件系统挂载，即文件系统安装/装载</li>
<li>在VFS中注册新挂载的文件系统。内存中的挂载表包含每个文件系统的相关信息，包括文件系统类型、容量大小等</li>
<li>新挂载的文件系统，要向VFS提供一个函数地址列表</li>
<li>将新文件加到挂载点，也就是将新文件系统挂载在某个父目录下</li>
</ul>
</li>
</ul>
<h1 id="第五章-io设备">第五章 I/O设备</h1>
<h2 id="51_1-i-o设备的概念和分类">5.1_1 I-O设备的概念和分类</h2>
<h3 id="io设备的基本概念和分类">I/O设备的基本概念和分类</h3>
<ul>
<li>什么是I/O设备
<ul>
<li>I/O就是输入/输出</li>
<li>I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</li>
</ul>
</li>
<li>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作
<ul>
<li>Write操作：向外部设备写出数据</li>
<li>Read操作：从外部设备读入数据</li>
</ul>
</li>
<li>I/O设备的分类——按使用特性
<ul>
<li>人机交互类外部设备
<ul>
<li>数据传输速度慢</li>
<li>鼠标、键盘、打印机等</li>
</ul>
</li>
<li>存储设备
<ul>
<li>数据传输速度快</li>
<li>移动硬盘、光盘等</li>
</ul>
</li>
<li>网络通信设备
<ul>
<li>传输速度介于上述二者之间</li>
<li>调制解调器等</li>
</ul>
</li>
</ul>
</li>
<li>I/O设备的分类——按传输速率分类
<ul>
<li>低速设备
<ul>
<li>鼠标、键盘等</li>
<li>传输速率为每秒几个到几百字节</li>
</ul>
</li>
<li>中速设备
<ul>
<li>激光打印机等</li>
<li>传输速率为每秒数千至上万个字节</li>
</ul>
</li>
<li>高速设备
<ul>
<li>磁盘等</li>
<li>传输速率为每秒数千字节至千兆字节的设备</li>
</ul>
</li>
</ul>
</li>
<li>I/O设备的分类——按信息交换的单位
<ul>
<li>块设备
<ul>
<li>如磁盘等</li>
<li>数据传输的基本单位是“块”</li>
<li>传输速率高，可寻址，即对它可随机地读/写任一块</li>
</ul>
</li>
<li>字符设备
<ul>
<li>鼠标、键盘灯</li>
<li>数据传输的基本单位是字符</li>
<li>传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-45">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-15%2009.50.48.png" alt=""></p>
<h2 id="51_2-i-o控制器">5.1_2 I-O控制器</h2>
<h3 id="机械部件">机械部件</h3>
<ul>
<li>用来执行具体的I/O操作</li>
<li>如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面</li>
</ul>
<h3 id="电子部件">电子部件</h3>
<ul>
<li>
<p>I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板</p>
</li>
<li>
<p>I/O控制器(设备控制器)</p>
<ul>
<li>接受和识别CPU发出的命令
<ul>
<li>如CPU发来的read/write命令，I/O控制器中会有相应的<strong>控制寄存器</strong>来存放命令和参数</li>
</ul>
</li>
<li>向CPU报告设备的状态
<ul>
<li><strong>状态寄存器</strong>，用于记录I/O设备的当前状态，如：1表示空闲，0表示忙碌</li>
</ul>
</li>
<li>数据交换
<ul>
<li>I/O控制器中会设置相应的<strong>数据寄存器</strong></li>
<li>输出时，数据寄存器用于暂时存放CPU发来的数据，之后再由控制器传送设备</li>
<li>输入时，数据集村用用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据</li>
</ul>
</li>
<li>地址识别
<ul>
<li>给寄存器编址</li>
<li>I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</li>
</ul>
</li>
</ul>
</li>
<li>
<p>I/O控制器的组成
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2012.17.57.png" alt=""></p>
</li>
<li>
<p>注意</p>
<ul>
<li>一个I/O控制器可能会对应多个设备</li>
<li>数据寄存器、控制寄存器、状态寄存器可能有多个(如：每个控制/状态寄存器对应一个具体的设备)，且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映像I/O；另一些计算机则采用I/O专用地址，即寄存器独立编址</li>
</ul>
</li>
<li>
<p>内存映像I/O vs 寄存器独立编址
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2016.35.09.png" alt=""></p>
</li>
</ul>
<h3 id="总结-46">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2016.36.13.png" alt=""></p>
<h2 id="51_3-io控制方式">5.1_3 I/O控制方式</h2>
<h3 id="程序直接控制方式">程序直接控制方式</h3>
<ul>
<li>完成一次读操作的流程(Key word: 轮询)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2016.39.54.png" alt=""></li>
<li>CPU干预的频率
<ul>
<li>很频繁，I/O操作开始之前、完成之后需要CPU介入，并且在等待I/O完成的过程中CPU需要不断地轮询检查</li>
</ul>
</li>
<li>数据传送的单位
<ul>
<li>每次读/写一个字</li>
</ul>
</li>
<li>数据的流向
<ul>
<li>读操作(数据流入)：I/O设备-&gt;CPU-&gt;内存</li>
<li>写操作(数据输出)：内存-&gt;CPU-&gt;I/O设备</li>
<li>每个字的读/写都需要CPU的帮助</li>
</ul>
</li>
<li>主要缺点和主要优点
<ul>
<li>优点：实现简单。在读/写指令之后，加上实现循环检查的一系列指令即可(因此才称为“程序直接控制方式”)</li>
<li>缺点：CPU和I/O设备只能串行工作，CPU需要一直轮训检查，长期处于“忙等”状态，CPU利用率低
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2016.48.32.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="中断驱动方式">中断驱动方式</h3>
<ul>
<li>引入中断机制</li>
<li>将等待I/O的进程阻塞</li>
<li>CPU检测到终端信号后，执行中断处理程序</li>
<li>I/O操作完成后，CPU恢复等待I/O进程(或其他进程)的运行环境，然后继续执行</li>
<li>注意
<ul>
<li>CPU会在每个指令周期的末尾检查中断</li>
<li>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能</li>
</ul>
</li>
<li>完成一次读/写操作的流程(Key word: 中断)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2016.53.58.png" alt=""></li>
<li>CPU干预的频率
<ul>
<li>每次I/O操作开始之前、完成之后需要CPU介入</li>
<li>等待I/O完成的过程中CPU可以切换到别的进程执行</li>
</ul>
</li>
<li>数据传送的单位
<ul>
<li>每次读/写一个字</li>
</ul>
</li>
<li>数据的流向
<ul>
<li>读操作(数据流入)：I/O设备-&gt;CPU-&gt;内存</li>
<li>写操作(数据流出)：内存-&gt;CPU-&gt;I/O设备</li>
</ul>
</li>
<li>主要优点和主要缺点
<ul>
<li>优点：CPU不再需要不停地轮询，CPU和I/O设备可并行工作，CPU利用率得到明显提升</li>
<li>缺点
<ul>
<li>每个字在I/O设备与内存之间的传输，都需要经过CPU</li>
<li>频繁的中断处理会消耗更多的CPU时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="dma方式">DMA方式</h3>
<ul>
<li>DMA方式/直接存储器存取</li>
<li>主要用于块设备的I/O控制</li>
<li>相对于中断驱动方式的改进
<ul>
<li>数据的传送单位是“块”。不再是一个字、一个字的传送</li>
<li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为中介</li>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2017.15.01.png" alt=""></li>
</ul>
</li>
<li>完成一次读/写操作的流程
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2017.16.13.png" alt=""></li>
<li>CPU干预的频率
<ul>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>
</ul>
</li>
<li>数据传送的单位
<ul>
<li>每次读/写一个或多个块</li>
<li>每次读写的只能是连续的多个块，且这些块存入内存后在内存中也必须是连续的</li>
<li>如果读取的多个块不连续，同样需要发出多次中断请求</li>
</ul>
</li>
<li>数据的流向(不再需要经过CPU)
<ul>
<li>读操作：I/O设备-&gt;内存</li>
<li>写操作：内存-&gt;I/O设备</li>
</ul>
</li>
<li>主要优点和主要缺点
<ul>
<li>优点
<ul>
<li>数据传输以块为单位，CPU介入频率进一步降低</li>
<li>数据的传输不再需要先经过CPU在写入内存，数据传输效率进一步增加，CPU和I/O设备的并行性得到提升</li>
</ul>
</li>
<li>缺点
<ul>
<li>CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块</li>
<li>如果要读/写多个离散存储的数据块，或者要讲数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="通道控制方式">通道控制方式</h3>
<ul>
<li>
<p>通道：一种硬件，通道可以识别并执行一系列通道指令
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2017.20.26.png" alt=""></p>
</li>
<li>
<p>完成一次读/写操作的流程
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2017.21.23.png" alt=""></p>
</li>
<li>
<p>CPU干预的频率</p>
<ul>
<li>极低，通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读/写后才需要发出中断信号，请求CPU干预</li>
</ul>
</li>
<li>
<p>数据传送的单位</p>
<ul>
<li>每次读/写一组数据块</li>
</ul>
</li>
<li>
<p>数据的流向(在通道的控制下进行)</p>
<ul>
<li>读操作: I/O设备-&gt;内存</li>
<li>写操作: 内存-&gt;I/O设备</li>
</ul>
</li>
<li>
<p>主要缺点和主要优点</p>
<ul>
<li>缺点
<ul>
<li>实现复杂</li>
<li>需要专门的通道硬件支持</li>
</ul>
</li>
<li>优点
<ul>
<li>CPU、通道、I/O设备可并行工作，资源利用率很高</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-47">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-16%2017.26.39.png" alt=""></p>
<h2 id="51_4-io软件层次结构">5.1_4 I/O软件层次结构</h2>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-17%2010.32.29.png" alt=""></p>
<h3 id="用户层软件">用户层软件</h3>
<ul>
<li>用户层软件实现了与用户交互的接口
<ul>
<li>用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作</li>
</ul>
</li>
<li>用户层软件将用户请求翻译成格式化的I/O请求，并通过“系统调用”请求操作系统内核的服务
<ul>
<li>printf会被翻译成等价的write系统调用，用户层软件也会在系统调用时填入相应参数</li>
<li>调用的是<strong>设备独立性软件</strong>的功能</li>
<li>设备独立性软件：处理系统调用，又称为系统调用处理层</li>
</ul>
</li>
</ul>
<h3 id="设备独立性软件">设备独立性软件</h3>
<ul>
<li>又称为设备无关性软件</li>
<li>向上层提供统一的调用接口(如read/write系统调用)</li>
<li>设备的保护
<ul>
<li>设备被看作是一种特殊的文件，不同用户对设备的访问权限不一样</li>
</ul>
</li>
<li>差错处理</li>
<li>设备的分配与回收</li>
<li>数据缓冲区管理
<ul>
<li>可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</li>
</ul>
</li>
<li>建立逻辑设备名到物理设备名的映射关系，根据设备类型选择调用相应的驱动程序
<ul>
<li>逻辑设备表LUT(逻辑设备名+物理设备名+驱动程序入口地址)</li>
<li>管理方式
<ul>
<li>整个系统还设置一张LUT，只适合于单用户操作系统</li>
<li>为每个用户设置一张LUT</li>
</ul>
</li>
<li>不同的设备需要不同的驱动程序
<ul>
<li>厂家会提供与设备相对应的驱动程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备驱动程序">设备驱动程序</h3>
<ul>
<li>主要负责对硬件设备的具体控制，将上层发出的一系列命令转换成特定设备“能听得懂”的一系列操作。包括设备寄存器；检查设备状态等</li>
<li>驱动程序一般会以一个独立进程的方式存在</li>
</ul>
<h3 id="中断处理程序">中断处理程序</h3>
<ul>
<li>中断信号类型-&gt;中断处理程序</li>
</ul>
<h3 id="硬件">硬件</h3>
<ul>
<li>不同的I/O设备有不同的硬件特性，具体细节只有设备的厂家才知道</li>
<li>因此厂家需要根据设备的硬件特性设计并提供相应的驱动程序</li>
</ul>
<h3 id="总结-48">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-17%2010.48.49.png" alt=""></p>
<h2 id="51_5-输入输出应用程序接口设备驱动程序接口">5.1_5 输入输出应用程序接口&amp;设备驱动程序接口</h2>
<h3 id="输入输出应用程序接口">输入/输出应用程序接口</h3>
<ul>
<li>
<p>用户层I/O软件与设备独立软件之间的接口</p>
</li>
<li>
<p>字符设备接口</p>
<ul>
<li>get/put系统调用
<ul>
<li>向字符设备读/写一个字符</li>
</ul>
</li>
</ul>
</li>
<li>
<p>块设备接口</p>
<ul>
<li>read/write系统调用
<ul>
<li>向块设备的读写指针位置读/写多个字符</li>
</ul>
</li>
<li>seek系统调用
<ul>
<li>修改读写指针的位置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>网络设备接口</p>
<ul>
<li>又称“网络套接字(socket)接口”</li>
<li>socket系统调用
<ul>
<li>创建一个网络套接字，需要指明网络协议(TCP/UDP)</li>
<li>bind: 将套接字绑定到某个本地“端口”</li>
<li>connect: 将套接字连接到远程地址+端口</li>
<li>read/write: 从套接字读/写数据
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-17%2011.13.21.png" alt=""></li>
</ul>
</li>
</ul>
</li>
<li>
<p>阻塞/非阻塞I/O</p>
<ul>
<li>阻塞I/O：应用程序发出I/O系统调用，进程需转为阻塞态等待
<ul>
<li>字符设备接口——从键盘读一个字符get</li>
</ul>
</li>
<li>非阻塞I/O：应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待
<ul>
<li>块设备接口——往磁盘写数据write</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备驱动程序接口">设备驱动程序接口</h3>
<ul>
<li>若各公司开发的设备驱动程序接口不统一，则操作系统很难调用设备驱动程序</li>
<li>操作系统规定号设备驱动程序的接口标准，各厂商必须按要求开发设备驱动程序</li>
<li>不同的操作系统，对设备驱动程序接口的标准各不相同
<ul>
<li>设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-17%2011.20.44.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="总结-49">总结</h3>
<h2 id="52_1-io核心子系统">5.2_1 IO核心子系统</h2>
<ul>
<li>设备独立性软件、设备驱动程序、中断处理程序属于操作系统的内核部分，即“I/O系统”，或称“I/O核心子系统”</li>
<li>假脱机技术(SPOOLing技术)在用户层软件实现</li>
<li>I/O调度、设备保护、设备分配与回收、缓冲区管理(即缓冲与高速缓存)在设备独立性软件层实现</li>
</ul>
<h3 id="io调度">I/O调度</h3>
<ul>
<li>用某种算法确定一个好的顺序来处理各个I/O请求</li>
<li>磁盘调度：先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法
<ul>
<li>当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序</li>
</ul>
</li>
<li>打印机等设备也可以用先来先服务算法、优先级算法、短作业优先等算法来确定I/O调度顺序</li>
</ul>
<h3 id="设备保护">设备保护</h3>
<ul>
<li>在UNIX系统中，设备被看作是一种特殊的文件，每个设备也会有对应的FCB，当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能</li>
</ul>
<h3 id="总结-50">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-18%2009.27.23.png" alt=""></p>
<h2 id="52_2-假脱机技术">5.2_2 假脱机技术</h2>
<h3 id="什么是脱机技术">什么是脱机技术</h3>
<ul>
<li>批处理阶段引入了脱机输入/输出技术(用磁带完成)
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-18%2009.30.33.png" alt=""></li>
</ul>
<h3 id="假脱机技术输入井和输出井">假脱机技术——输入井和输出井</h3>
<ul>
<li>又称SPOLLing技术，用软件的方式模拟脱机技术</li>
<li>输入进程-&gt;输入井</li>
<li>输出进程&lt;-输出井
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-18%2009.33.26.png" alt=""></li>
<li>输入缓冲区和输出缓冲区都在内存中</li>
</ul>
<h3 id="共享打印机原理分析">共享打印机原理分析</h3>
<blockquote>
<p>独占式设备——只允许各个进程串行使用的设备，一段时间内只能满足一个进程的请求        <br>
共享设备——允许多个进程“同时”使用的设备(宏观上同时使用，微观上可能是交替使用)。可以同时满足多个进程的使用请求。</p>
</blockquote>
<ul>
<li>打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设备”</li>
<li>当有多个用户进程输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们，而是由假脱机管理进程为每个进程做两件事
<ul>
<li>在磁盘输出井中为进程申请一个空闲缓冲区，并将要打印的数据送入其中</li>
<li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中，再将该表挂到假脱机文件队列上</li>
<li>打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印-&gt;一次处理完全部的打印任务</li>
</ul>
</li>
<li>虽然系统中只哦于一个打印机，但在每个进程提出打印请求时，系统都会为其再输出井中分配一个存储区(相当于分配了一个逻辑设备)，使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享</li>
<li>SPOLLing 技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-18%2009.45.00.png" alt=""></li>
</ul>
<h3 id="总结-51">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-18%2009.45.47.png" alt=""></p>
<h2 id="52_3-设备的分配与回收">5.2_3 设备的分配与回收</h2>
<h3 id="设备分配时应考虑的因素">设备分配时应考虑的因素</h3>
<ul>
<li>设备的固有属性
<ul>
<li>独占设备
<ul>
<li>如打印机</li>
</ul>
</li>
<li>共享设备
<ul>
<li>如磁盘</li>
<li>往往是共享设备，而微观上交替使用</li>
</ul>
</li>
<li>虚拟设备
<ul>
<li>SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用(如采用SPOOLing技术实现的共享打印机)</li>
</ul>
</li>
</ul>
</li>
<li>设备分配算法
<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
<li>段任务优先</li>
</ul>
</li>
<li>设备分配中的安全性
<ul>
<li>安全分配方式
<ul>
<li>为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒</li>
<li>一个时间段内每个进程只能使用一个设备
<ul>
<li>优点：破坏了“请求和保持”条件，不会死锁</li>
<li>缺点：对一个进程来说CPU和I/O只能串行工作</li>
</ul>
</li>
</ul>
</li>
<li>不安全分配方式
<ul>
<li>进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求</li>
<li>只有某个I/O请求得不到满足时才将进程阻塞</li>
<li>一个进程可以同时使用多个设备
<ul>
<li>优点：进程的计算任务和I/O任务可以并行处理，使进程迅速推进</li>
<li>缺点：有可能发生死锁(死锁避免、死锁的检测和解除)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="静态分配和动态分配">静态分配和动态分配</h3>
<ul>
<li>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源
<ul>
<li>破坏了“请求和保持”条件，不会发生死锁</li>
</ul>
</li>
<li>动态分配
<ul>
<li>进程运行过程中动态申请设备资源</li>
</ul>
</li>
</ul>
<h3 id="设备分配管理中的数据结构">设备分配管理中的数据结构</h3>
<blockquote>
<p>设备、控制器、通道之间的关系       <br>
一个通道可以控制多个设备控制器，每个设备控制器可以控制多个设备</p>
</blockquote>
<ul>
<li>
<p>设备控制表DCT</p>
<ul>
<li>系统为每个设备配置一张DCT，用于记录设备情况</li>
<li>设备类型</li>
<li>设别标识符
<ul>
<li>物理设备名，设备的唯一id，系统中每个设备的物理设备名统一</li>
</ul>
</li>
<li>设备状态
<ul>
<li>忙碌/空闲/故障</li>
</ul>
</li>
<li>指向控制器表的指针
<ul>
<li>每个设备由一个控制器控制，该指针可找到相应控制器的信息</li>
</ul>
</li>
<li>重复执行次数或时间
<ul>
<li>当重复执行多次I/O操作后人不成功，才任务此次I/O失败</li>
</ul>
</li>
<li>设备队列的队首指针
<ul>
<li>指向正在等待该设备的进程队列(由进程PCB组成队列)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>控制器控制表(COCT)</p>
<ul>
<li>每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理</li>
<li>控制器标识符
<ul>
<li>各个控制器的唯一ID</li>
</ul>
</li>
<li>控制器状态
<ul>
<li>忙碌/空闲/故障</li>
</ul>
</li>
<li>指向通道表的指针
<ul>
<li>每个控制器由一个通道控制，该指针可找到相应通道的信息</li>
</ul>
</li>
<li>控制器队列的队首指针
<ul>
<li>指向正在等待该控制器的进程队列(由进程PCB组成队列)</li>
</ul>
</li>
<li>控制器队列的队尾指针</li>
</ul>
</li>
<li>
<p>通道控制表(CHCT)</p>
<ul>
<li>每个通道都会对应一张CHCT，操作系统根据CHCT的信息对通道进行操作和管理</li>
<li>通道标识符</li>
<li>通道状态</li>
<li>与通道连接的控制器表首址</li>
<li>通道队列的队首指针</li>
<li>通道队列的队尾指针</li>
</ul>
</li>
<li>
<p>系统设备表(SDT)</p>
<ul>
<li>记录了系统中全部设备的情况，每个设备对应一个表目</li>
<li>每个表目
<ul>
<li>设备类型</li>
<li>设备标识符</li>
<li>DCT</li>
<li>驱动程序入口</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设备分配的具体步骤">设备分配的具体步骤</h3>
<ul>
<li>根据物理设备名-&gt;<strong>逻辑设备名</strong>(其实是“设备类型”)查找SDT</li>
<li>根据SDT找到DCT，若设备忙碌则将进程PCB, 若设备忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程
<ul>
<li>-&gt;找到用户指定类型的、空闲的设备，将其分配给进程，操作系统在<strong>逻辑设备表中</strong>(LUT)新增一个表项-&gt;之后可直接通过逻辑设备表知道用户实际要使用的是哪个物理设备，并且也能知道该设备的驱动程序入口地址</li>
</ul>
</li>
<li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配给进程</li>
<li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进程</li>
<li>只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I/O设备进行数据传送</li>
<li>缺点
<ul>
<li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ul>
</li>
<li>改进的方法
<ul>
<li>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</li>
</ul>
</li>
<li>逻辑设备表的设置问题
<ul>
<li>整个系统只有一张LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</li>
<li>每个用户一张LUT：不同用户的逻辑设备名可重复，适用于多用户操作系统</li>
</ul>
</li>
</ul>
<h2 id="52_4-缓冲区管理">5.2_4 缓冲区管理</h2>
<h3 id="什么是缓冲区有什么作用">什么是缓冲区？有什么作用？</h3>
<ul>
<li>一个存储区域，由专门的硬件寄存器组成/可用内存作为缓冲区</li>
<li>使用硬件作为缓冲区的成本较高，容量较小，一般仅用在对速度要求非常高的场合</li>
<li>一般情况下，更多的是利用内存作为缓冲区</li>
</ul>
<h3 id="缓冲区有什么作用">缓冲区有什么作用</h3>
<ul>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li>
<li>解决数据粒度不匹配的问题
<ul>
<li>如输出进程每次可以生成一块数据，但I/O设备每次只能输出一个字符</li>
</ul>
</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ul>
<h3 id="单缓冲">单缓冲</h3>
<ul>
<li>某用户进程请求某种块设备读入若干块的数据</li>
<li>操作系统在驻村中为其分配一个缓冲区(没有特别说明时，一个缓冲区的大小就是一个块)</li>
<li>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据读出</li>
<li>用户进程的内存空间中，会分出一片工作区来接受输入/输出数据(一般也默认工作区大小与缓冲区相同)</li>
<li>计算：
<ul>
<li>每处理一块数据平均需要多久</li>
<li>技巧：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</li>
<li>在“单缓冲”提醒中，可以假设初始状态为工作去满、缓冲区没空
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-19%2018.28.16.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="双缓冲">双缓冲</h3>
<ul>
<li>在主存中为一个用户进程分配两个缓冲区</li>
<li>假设初始状态为
<ul>
<li>工作区空，其中一个缓冲区满，另一个缓冲区空</li>
</ul>
</li>
<li>采用双缓冲区策略，处理一个数据块的平均耗时为Max(T, C+M)
<ul>
<li>T是数据存入缓冲区的时间</li>
<li>C是CPU处理的时间，M是将数据从缓冲区读到工作区的时间</li>
</ul>
</li>
</ul>
<h3 id="使用单双缓冲在通信时的区别">使用单/双缓冲在通信时的区别</h3>
<ul>
<li>两台机器之间通信时，可以配置缓冲区用于数据的发送和接受</li>
<li>单缓冲区只能单向传输</li>
<li>两台机器都设置双缓冲区，同一时刻可实现线双向的数据传输
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-19%2018.41.22.png" alt=""></li>
</ul>
<h3 id="循环缓冲区">循环缓冲区</h3>
<ul>
<li>将多个大小相等的缓冲区链接成一个循环队列
<ul>
<li>in指针，指向下一个可以冲入数据的空缓冲区</li>
<li>out指针，指向下一个可以取出数据的满缓冲区</li>
</ul>
</li>
</ul>
<h3 id="缓冲池">缓冲池</h3>
<ul>
<li>由系统中共用的缓冲区组成</li>
<li>这些缓冲区可以按使用情况可分为：
<ul>
<li>空缓冲区队列</li>
<li>装满输入数据的缓冲队列(输入队列)</li>
<li>装满输出数据的缓冲队列(输出队列)</li>
</ul>
</li>
<li>按缓冲区扮演的功能
<ul>
<li>用于收容数据的工作缓冲区bin</li>
<li>用于提取输入数据的工作缓冲区sin</li>
<li>用于收容输出数据的工作缓冲区hout</li>
<li>用于提取输出数据的工作换从功能区sout
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-19%2018.47.05.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="总结-52">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-19%2018.47.40.png" alt=""></p>
<h2 id="53_1-磁盘的结构">5.3_1 磁盘的结构</h2>
<h3 id="磁盘磁道扇区">磁盘、磁道、扇区</h3>
<ul>
<li>磁盘表面有一些磁性物质组成，可以用这些磁性物质来记录二进制数据</li>
<li>磁盘的盘面被划分成一个个<strong>磁道</strong>，这样的一个“圈”就是一个磁道</li>
<li>一个磁道又被划分成一个个扇区，每个扇区就是一个<strong>磁盘块</strong>，各个扇区存放的数据量相同
<ul>
<li>最内侧磁道上的扇区面积最小，因此数据密度最大</li>
</ul>
</li>
<li>如何在磁盘中读/写数据
<ul>
<li>把“磁头”移动到想要读/写的扇区所在的磁道</li>
<li>磁盘会转动起来，让目标扇区从磁头下面划过，才能完成对扇区的读/写操作</li>
</ul>
</li>
</ul>
<h3 id="盘面柱面">盘面、柱面</h3>
<ul>
<li>一个盘片可能会有两个盘面</li>
<li>每个<em>盘面</em>对应一个磁头</li>
<li>所有磁头连接在同一个磁臂上，因此所有磁头只能“共进退”</li>
<li>所有盘面中相对位置相同的磁道组成<strong>柱面</strong></li>
<li>定位：柱面号、盘面号、扇区号
<ul>
<li>根据柱面号移动磁臂，让磁头指向指定柱面</li>
<li>激活指定盘面对应的磁头</li>
<li>盘面旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写一个字</li>
</ul>
</li>
</ul>
<h3 id="磁盘的分类">磁盘的分类</h3>
<ul>
<li>根据磁头
<ul>
<li><strong>活动头磁盘</strong>
<ul>
<li>磁头可以来回伸缩来带动磁头定位磁道</li>
</ul>
</li>
<li>磁头不可移动的成为<strong>固定头磁盘</strong>。这种磁盘中每个磁道有一个磁头</li>
</ul>
</li>
<li>盘片是否可以更换
<ul>
<li><strong>可换盘磁盘</strong></li>
<li><strong>固定盘磁盘</strong></li>
</ul>
</li>
</ul>
<h3 id="总结-53">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-19%2019.04.36.png" alt=""></p>
<h2 id="53_2-磁盘调度算法">5.3_2 磁盘调度算法</h2>
<h3 id="一次磁盘读写操作需要的时间">一次磁盘读/写操作需要的时间</h3>
<ul>
<li>寻找时间$T_s$(寻道时间)
<ul>
<li>移动磁头到指定磁道
<ul>
<li>启动磁头臂s</li>
<li>移动磁头，每跨越一个磁道耗时m，总共需要跨越n条磁道</li>
<li>$T_s$ = s + m * n</li>
</ul>
</li>
</ul>
</li>
<li>延迟时间$T_R$
<ul>
<li>通过旋转磁盘，使磁头定位到目标扇区所需要的时间</li>
<li>转速为r</li>
<li>$T_R$ = (1 / 2) * (1 / r) = 1 / (2 r)
<ul>
<li>1 / r就是转一圈需要的时间</li>
<li>找到目标扇区平均需要转半圈</li>
</ul>
</li>
</ul>
</li>
<li>传输时间$T_t$
<ul>
<li>从磁盘读出或向磁盘写入数据所经历的时间</li>
<li>磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N</li>
<li>$T_t$ = (1 / r) * (b / N) = b / (r * N)
<ul>
<li>b字节的数据需要b/N个磁道才能存储</li>
<li>读/写一个磁道所需时间为1/r</li>
</ul>
</li>
</ul>
</li>
<li>总的平均存取时间
<ul>
<li>$T_a$ = $T_S$ + 1/(2r) + b / (rN)</li>
</ul>
</li>
<li>延迟时间和运输时间都与磁盘转速有关，且为线性相关</li>
<li>而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</li>
<li>但操作系统的磁盘调度算法会直接影响寻道时间</li>
</ul>
<h3 id="磁盘调度算法">磁盘调度算法</h3>
<ul>
<li>先来先服务FCFS
<ul>
<li>根据进程请求访问磁盘的先后顺序来调度</li>
<li>优点：公平；如果请求的磁道比较集中的话，算法性能还算过得去</li>
<li>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长</li>
</ul>
</li>
<li>最短寻找时间优先SSTF
<ul>
<li>优先处理与当前磁头最近的磁道</li>
<li>可以保证每次寻道时间最短，但是并不能保证总的寻道时间最短(贪心算法的思想)</li>
<li>优点：性能较好，平均寻道时间短</li>
<li>缺点：可能产生“饥饿”现象
<ul>
<li>原因：磁头在一个小区域内来回来去地移动</li>
</ul>
</li>
</ul>
</li>
<li>扫描算法SCAN (电梯算法)
<ul>
<li>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动</li>
<li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</li>
<li>缺点
<ul>
<li>只有到达最边上的磁道才能改变磁头移动方向</li>
<li>对各个位置磁道的响应频率不平均</li>
</ul>
</li>
</ul>
</li>
<li>LOOK调度算法
<ul>
<li>对扫描算法的改进</li>
<li>如果在磁头移动方向上已经没有别的请求，就可以改变磁头移动方向</li>
</ul>
</li>
<li>循环扫描算法C-SCAN
<ul>
<li>只有磁头朝某个特定方向移动时才处理磁道访问请求，返回时直接快速移动至起始端而不处理任何请求</li>
<li>优点：比起SCAN来，对于各个位置磁道的响应频率很平均</li>
<li>缺点：
<ul>
<li>只有到达最边上的磁道时才能改变磁头移动方向</li>
<li>磁头返回时不必返回最左侧</li>
<li>比起SCAN算法来，平均寻道时间更长</li>
</ul>
</li>
</ul>
</li>
<li>C-LOOK算法
<ul>
<li>在C-SCAN的基础上改进</li>
<li>如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可</li>
<li>优点：比起C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>
</ul>
</li>
</ul>
<h3 id="总结-54">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-20%2016.57.46.png" alt=""></p>
<h2 id="53_3-减少磁盘延迟时间的方法">5.3_3 减少磁盘延迟时间的方法</h2>
<ul>
<li>如果逻辑上相邻的数据在物理上也相邻，无法连续读入(磁盘在不断转动)</li>
</ul>
<h3 id="交替编号">交替编号</h3>
<ul>
<li>让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-20%2017.01.52.png" alt=""></li>
</ul>
<h3 id="逻辑地址结构设计">逻辑地址结构设计</h3>
<ul>
<li>柱面号，盘面号，扇区号
<ul>
<li>此顺序的地址结构可以减少磁头移动消耗的时间</li>
</ul>
</li>
</ul>
<h3 id="错位命名">错位命名</h3>
<ul>
<li>所有盘面都是一起连轴旋转
<ul>
<li>与交替编号原理相似
<img src="/images/%E6%88%AA%E5%B1%8F2024-11-20%2017.09.58.png" alt=""></li>
</ul>
</li>
</ul>
<h3 id="总结-55">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-20%2017.11.01.png" alt=""></p>
<h2 id="53_4-磁盘的管理">5.3_4 磁盘的管理</h2>
<h3 id="磁盘初始化">磁盘初始化</h3>
<ul>
<li>低级格式化(物理格式化)
<ul>
<li>划分扇区</li>
<li>头、数据区域、尾</li>
<li>头、尾中存放扇区校验码(如奇偶校验、CRC循环冗余校验码等，校验码用于检验扇区中的数据是否发生错误)</li>
</ul>
</li>
<li>将磁盘分区，每个分区由若干柱面组成</li>
<li>逻辑格式化
<ul>
<li>创建文件系统</li>
<li>创建文件系统的根目录、初始化存储空间管理所用的数据结构</li>
</ul>
</li>
</ul>
<h3 id="引导块">引导块</h3>
<ul>
<li>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序(自举程序)完成的</li>
<li>ROM
<ul>
<li>只读存储器</li>
<li>不能修改</li>
<li>初始化程序存放位置</li>
<li>一般是出厂时就集成在主板上的</li>
</ul>
</li>
<li>现在的操作系统只在ROM中存放很小的“自举装入程序”
<ul>
<li>完整的自举程序放在磁盘的启动块(即引导块/启动分区)上</li>
<li>启动块位于磁盘的固定位置</li>
</ul>
</li>
<li>开机时计算机先运行“自举装入程序”，通过执行该程序就可以找到引导块，并将完整的“自举程序”读入内存，完成初始化</li>
<li>拥有启动分区的磁盘称为启动磁盘或系统磁盘(C:盘)</li>
</ul>
<h3 id="坏块的管理">坏块的管理</h3>
<ul>
<li>坏块：无法正常使用，硬件故障，操作系统无法修复</li>
<li>对于简单的磁盘，可以在逻辑格式化时，对整个磁盘进行坏块检查，表明哪些扇区是坏扇区(坏块<strong>对操作系统不透明</strong>)</li>
<li>复杂的磁盘系统：磁盘控制器(磁盘设备内部的一个硬件部件)会维护一个坏块链表
<ul>
<li>会保留一些“备用扇区”，用于替换坏块，这种方案称为<strong>扇区备用</strong>，坏块<strong>对操作系统透明</strong></li>
</ul>
</li>
</ul>
<h3 id="总结-56">总结</h3>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-20%2017.23.11.png" alt=""></p>
<h2 id="53_5-固态硬盘ssd">5.3_5 固态硬盘SSD</h2>
<p><img src="/images/%E6%88%AA%E5%B1%8F2024-11-20%2017.31.53.png" alt=""></p>
</article>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
</div>
<script type="application/javascript" src='https://y-m-m.github.io/js/toc.js'></script>
<link rel="stylesheet" href='https://y-m-m.github.io/css/toc.css' />

  
<div id="gitalk-container" class="gitalk-container"></div>
<link rel="stylesheet" href='https://y-m-m.github.io/css/gitalk.css'>
<script src='https://y-m-m.github.io/js/gitalk.min.js'></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23livxKNtTlPeMjV2H',
    clientSecret: '6d3bc9f47a1296f29628a63701ea5624cd28a26b',
    repo: 'y-m-m.github.io',
    owner: 'Y-M-M',
    admin: ['Y-M-M'],
    id: eval("location.pathname"), 
    distractionFreeMode: false 
  });
  (function() {
    gitalk.render('gitalk-container');
  })();
</script>

</div>

  <div class="footer container-xl width-full p-responsive">
  <div
    class="position-relative d-flex flex-row-reverse flex-lg-row flex-wrap flex-lg-nowrap flex-justify-center flex-lg-justify-between flex-sm-items-center pt-6 pb-2 mt-6 f6 text-gray border-top border-gray-light ">
    <a aria-label="Homepage" title="GitHub" class="footer-octicon d-none d-lg-block mr-lg-4" href="https://y-m-m.github.io/">
      <svg height="24" class="octicon octicon-mark-github" viewBox="0 0 16 16" version="1.1" width="24">
        <path fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z">
        </path>
      </svg>
    </a>
    <ul class="list-style-none d-flex flex-wrap col-12 flex-justify-center flex-lg-justify-between mb-2 mb-lg-0">
      
      <li class="mr-3 mr-lg-0">Theme by <a href='https://github.com/MeiK2333/github-style'>github-style</a></li>
      
    </ul>
  </div>
  <div class="d-flex flex-justify-center pb-6">
    <span class="f6 text-gray-light"></span>
  </div>


</div>
</body>

<script type="application/javascript" src="https://y-m-m.github.io/js/github-style.js"></script>





<script src="https://cdn.jsdelivr.net/npm/fuse.js/dist/fuse.min.js"></script>
<script type="application/javascript" src='https://y-m-m.github.io/js/search.js'></script>



</html>